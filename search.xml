<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>qt 动画 顺序 轮播图轮播图</title>
      <link href="/carousel-demo/"/>
      <url>/carousel-demo/</url>
      
        <content type="html"><![CDATA[<p>​                                     </p><h3 id="Show-time"><a href="#Show-time" class="headerlink" title="Show time!"></a>Show time!</h3><iframe height="320" width="900" frameborder="no" border="0" src="show.gif"> </iframe>简单来说，就是一个轮播图。<p>切换的时候是有动画的。</p><p>点击下面的按钮可以切换动画。</p><p>图片可以是很多张很多张的，但显示在窗口上的只有三张，但它们的顺序是不会变的。</p><p>如果能直接有qml上面的pathview的组件能直接使用那就更好了，就不能自己敲widget了。</p><p>​                   </p><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>首先，大概是这么一个窗口：</p><p><img src="/carousel-demo/designer.png"></p><p>其中，灰色部分就是整个widget的大小，就是说leftprepare和rightprepare是在widget外的，就是准备着的。</p><p>左移和右移差不多，那只要明白左移一次的要点基本就差不多了：</p><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p>移动由qanimation实现，就是动画，动画说白了就是产生一堆间隔很小很小的数列设置进控件的属性，所以改变label的geometry就有了动画移动的效果。</p><h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>位置是先固定好的，由于五个label的geometry会改变，所以先定义五个rect记录着固定的位置</p><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><p>重中之重，看起来再移动，其实并没有真正的移动。</p><p>一次左移，众所周知，就是left移到leftprepare，middle移到left，right移到left，rightprepare移到right，没错是这样，但如果想有第二次，第三次，第n次，就必须做一些顺序处理了，毕竟位置已经都变了。</p><p>哈哈哈但天才并不想处理label，处理的是图片的顺序。</p><p>上面 [ 位置 ] 的用法来了，简单的说，无论移动多少次，label们左移都是从left rect的位置移到leftprepare rect的位置，middle rect移到left rect…..，移动负责的只是显示了移动的效果。</p><h4 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h4><p>既然不处理控件移动后的顺序问题，还是得处理图片的顺序问题。加入从左到右插入了图片12345。</p><p>左移第一次，啥也不用动。</p><p>左移第二次开始，labelleft就要插入图片3了，图片顺序也就变成了23451。</p><p>换种说法，第一次左移，显示了图片2345的左移动画：</p><p><img src="/carousel-demo/move_1.png"></p><p>第二次左移则显示3451的左移动画：</p><p><img src="/carousel-demo/move_2.png"></p><p>第n(n&gt;1)次左移，先把labels上面的图片清空一遍再插入好新的图片顺序，显示图片(n+1)(n+2)…的移动动画，n&gt;图片数量时，用取余操作得到尾数即可（哇！是数学！），而label们只是重复的在固定的rect之间做移动。</p><p>而当左移完立刻搞一个右移，那又是另一种情况了，但道理是相同的，把图片顺序弄好就行。</p><h4 id="按钮控制"><a href="#按钮控制" class="headerlink" title="按钮控制"></a>按钮控制</h4><p>一张图片一个按钮，用buttongroup控制按钮，用变量对应图片和按钮，图片的按钮是一一对应的。</p><h4 id="移动数次"><a href="#移动数次" class="headerlink" title="移动数次"></a>移动数次</h4><p>当前显示的图片、按钮是1时，直接点击按钮3，也就是右移两次。</p><p>这个也好解决，加个定时器触发剩余次数就行了，至于定时器的时间，刚好就是动画执行的时间，等动画执行完就可以触发定时器进行下一次的移动。</p><p>值得注意，图片顺序是不能乱的，当移动数次的时候它在操作着这些顺序，这时顺序就不能再动了。必须等所有移动次数执行完再进行新一轮的移动。</p><p>​                           </p><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><p>把左移和右移的封装成一个函数，需要的时候调用就行。</p><p>ui里总共只有五个label，用链表直接把label们放进去，其中每次移动包含四个label的动画，左移和右移的动画是不同的，最好区分一下：</p><pre class=" language-c++"><code class="language-c++">for (int i = 0; i < 4; i++)&#123;    QPropertyAnimation *animation = new QPropertyAnimation(labelList.at(i), "geometry");    animationLeftList << animation;&#125;for (int i = 0; i < 4; i++)&#123;    QPropertyAnimation *animation = new QPropertyAnimation(labelList.at(4-i), "geometry");    animationRightList << animation;&#125;</code></pre><p>​                                                                  </p><p><strong>移动函数主要包括这些内容：</strong></p><p><strong>移动时启动动画，用QParallelAnimationGroup把管理四个动画：</strong></p><pre class=" language-c++"><code class="language-c++">QParallelAnimationGroup *m_group;m_group = new QParallelAnimationGroup(this);for (int i = 0; i < 4; i++)&#123;    animationRightList.at(i)->setDuration(mIntervalMsec);    animationRightList.at(i)->setStartValue(rectList.at(x);    animationRightList.at(i)->setEndValue(rectList.at(x));    animationRightList.at(i)->setLoopCount(1);    m_group->addAnimation(animationRightList.at(i));&#125;m_group->setDirection(QAbstractAnimation::Forward);m_group->start();</code></pre><p><strong>至于这个rectList以及后面的节点就看是左移函数还是右移函数了。</strong></p><p><strong>用两个flag（bool haveMovedLeftOnce\haveMovedRightOnce）处理判断是不是第一次移动，因为第一次移动是不用处理图片顺序的：</strong></p><pre class=" language-c++"><code class="language-c++">if (haveMovedLeftOnce)&#123;    imageOrderMove(DIRECTION_LEFT);&#125;else    haveMovedLeftOnce = true;</code></pre><p><strong>同时再新加变量定义移动顺序，如果左移完右移，图片顺序以及flag都是要更新的：</strong></p><pre class=" language-c++"><code class="language-c++">if (mDirection == DIRECTION_RIGHT)&#123;    haveMovedLeftOnce = false;    imageOrderMove(DIRECTION_RIGHT);&#125;</code></pre><p><strong>记得每次移动执行的时候，要给mDirection赋值，也要初始化这个值为除左移右移的两个值，即枚举变量了：</strong></p><pre class=" language-c++"><code class="language-c++">enum DIRECTION&#123;DIRECTION_LEFT = 0, DIRECTION_RIGHT, DIRECTION_NONE&#125;;</code></pre><p>​                               </p><p>这个ImageOrderMove，就是处理图片顺序的时候了，其实图片顺序相当于真正的轮播移动顺序了，定义好图片左移和右移的图片列表，方便插入label：</p><pre class=" language-c++"><code class="language-c++">void CarouselWidget::imageOrderMove(DIRECTION direction)&#123;    if (direction == DIRECTION_RIGHT)&#123;        QList<QImage *> tempList = mImageList;        for (int i = mImageList.count() - 1; i > 0 ; i--)&#123;            mImageList.replace(i, tempList.at(i-1));        &#125;        mImageList.replace(0, tempList.at(mImageList.count()-1));        for (int i = 0; i < labelList.count(); i++)&#123;            labelList.at(i)->clear();            labelList.at(i)->setPixmap(QPixmap::fromImage(mImageList.at(i)->scaled(labelList.at(i)->width(),labelList.at(i)->height(),Qt::KeepAspectRatio)));        &#125;    &#125;else if (direction == DIRECTION_LEFT)&#123;        QList<QImage *> tempList = mImageList;        for (int i = 0; i < mImageList.count() - 1; i++)&#123;            mImageList.replace(i, tempList.at(i+1));        &#125;        mImageList.replace(mImageList.count()-1, tempList.at(0));        for (int i = 0; i < labelList.count(); i++)&#123;            labelList.at(i)->clear();            labelList.at(i)->setPixmap(QPixmap::fromImage(mImageList.at(i)->scaled(labelList.at(i)->width(),labelList.at(i)->height(),Qt::KeepAspectRatio)));        &#125;    &#125;&#125;</code></pre><p>​                     </p><p>至于button、buttongroup：</p><pre class=" language-c++"><code class="language-c++">for (int i = 0; i < cnt; i++)&#123;    QPushButton *button = new QPushButton(ui->widgetButtons);    button->setMaximumSize(10,10);    button->setStyleSheet("QPushButton&#123;background-color: gray;  border-radius: 4px;border: 1px;&#125;"                          "QPushButton:hover&#123;background-color: blue; border-radius: 4px;border: 1px;&#125;"                         );    btnsGroup->addButton(button);    btnsGroup->setId(button, i);&#125;connect( btnsGroup, SIGNAL(buttonClicked (int)), this, SLOT(btnClickEvent(int)) );btnsGroup->button(currentIndex)->setStyleSheet("QPushButton&#123;background-color: blue;  border-radius: 4px;border: 1px;&#125;"                                               "QPushButton:hover&#123;background-color: blue; border-radius: 4px;border: 1px;&#125;"                                              );</code></pre><p>额记得要setId，不然后续遍历buttongroup的时候id是不对应的，很容易就段错误了。</p><p>而currentIndex就是对应当前中间的图片了。</p><p>点击的时候设置一下样式、判断一下左移还是右移，以及移动次数进行移动就行了：</p><pre class=" language-c++"><code class="language-c++">for (int i = 0; i < btnsGroup->buttons().count(); i++)&#123;    if (i == index)&#123;        btnsGroup->button(i)->setStyleSheet("QPushButton&#123;background-color: blue;  border-radius: 4px;border: 1px;&#125;"        "QPushButton:hover&#123;background-color: blue; border-radius: 4px;border: 1px;&#125;"    );    &#125;else&#123;        btnsGroup->button(i)->setStyleSheet("QPushButton&#123;background-color: gray;  border-radius: 4px;border: 1px;&#125;"        "QPushButton:hover&#123;background-color: blue; border-radius: 4px;border: 1px;&#125;"    );    &#125;&#125;    if (currentIndex > index)&#123;        mLeftMoveTimes = currentIndex - index;        currentIndex = index;        mTimer->disconnect();        connect(mTimer, SIGNAL(timeout()), this, SLOT(moveLeftOnce()));        for (int i = 0; i < btnsGroup->buttons().count(); i++)&#123;            btnsGroup->button(i)->setEnabled(false);        &#125;        moveLeftOnce();        mTimer->start(mIntervalMsec+10);    &#125;else if (index > currentIndex)&#123;        mLeftMoveTimes = index - currentIndex;        currentIndex = index;        mTimer->disconnect();        connect(mTimer, SIGNAL(timeout()), this, SLOT(moveRightOnce()));            for (int i = 0; i < btnsGroup->buttons().count(); i++)&#123;        btnsGroup->button(i)->setEnabled(false);    &#125;    moveRightOnce();    mTimer->start(mIntervalMsec+10);&#125;</code></pre><p>移动的时候button失能，移动完使能回来就行了，同时添加变量(mLeftMoveTimes)控制移动次数，所以在移动函数最前面加上：</p><pre class=" language-c++"><code class="language-c++">if (mLeftMoveTimes != 0)&#123;    mLeftMoveTimes--;&#125;else&#123;    mTimer->stop();    for (int i = 0; i < btnsGroup->buttons().count(); i++)&#123;        btnsGroup->button(i)->setEnabled(true);    &#125;    return ;&#125;</code></pre><p>​                       </p><h3 id="Done！"><a href="#Done！" class="headerlink" title="Done！"></a>Done！</h3><p>基本第一版本就这样结束了，还是怀念qml的pathview啊，多么方便快捷啊！</p>]]></content>
      
      
      
        <tags>
            
            <tag> qt </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt 动画 顺序 轮播图轮播图</title>
      <link href="/carousel-demo-2/"/>
      <url>/carousel-demo-2/</url>
      
        <content type="html"><![CDATA[<p>​                   </p><h3 id="再续前缘"><a href="#再续前缘" class="headerlink" title="再续前缘"></a>再续前缘</h3><p>噗嗤。</p><p>就是补充一下首版本，加一丢丢东西。</p><p>总所周知，首版本都是匆匆忙忙，事后就看看有什么可以细细记录一下和补充一下。</p><p>好吧，其实也不多。</p><p>​                        </p><h3 id="效果速看"><a href="#效果速看" class="headerlink" title="效果速看"></a>效果速看</h3><ol><li><strong>新增随着窗口大小改动而改变大小的效果</strong></li></ol><iframe height="500" width="1200" frameborder="no" border="0" src="show.gif"> </iframe><ol start="2"><li><strong>新增鼠标控制</strong></li></ol><iframe height="400" width="1000" frameborder="no" border="0" src="show-2.gif"> </iframe><ol start="3"><li><strong>处理图片少于五张的情景</strong></li><li><strong>添加测试背景</strong></li></ol><p>​                               </p><h3 id="内容细看"><a href="#内容细看" class="headerlink" title="内容细看"></a>内容细看</h3><p>啊哈哈哈哈哈哈哈哈哈哈哈嗝，上面有内味没？有得一哈哈哈哈哈好专业啊哈哈哈哈哈嗝。</p><p>算了算了认真点，</p><p>如虎添翼，锦上添花，雪中送炭</p><p>嗯嗯这些都是必须滴。</p><h4 id="1-搞清楚定位"><a href="#1-搞清楚定位" class="headerlink" title="1.搞清楚定位"></a>1.搞清楚定位</h4><p>首先本来就是设计成一个控件库内容的，所以就继承widget了和dialog没有任何关系了。</p><p>那么测试或者说看效果呢？就直接搞一个mainwindow然后把弄好的carousel widget新建放上去就行了。</p><p>​                     </p><h4 id="2-图片"><a href="#2-图片" class="headerlink" title="2.图片"></a>2.图片</h4><p>新建一个资源随便放几张进去，轮播图里是有一个图片列表的，而且图片链表的顺序十分重要。</p><p>虽然永远只有5张被加载，但图片链表永远都在那里，顺序遵循左移或右移的操作。</p><p>所以配合上一点，加起来就是：</p><pre class=" language-c++"><code class="language-c++">ui->setupUi(this);QList<QImage *> imgList;for (int i = 1; i < 7; i++)&#123;    QImage* img = new QImage;    img->load(QString(":/img/%1.jpg").arg(i));    imgList << img;&#125;carousel = new CarouselWidget(this);carousel->setGeometry(this->geometry());carousel->setImageList(imgList);</code></pre><p>这个ui就是qmainwindow了，里面就放一个轮播图就完了。</p><p>至于setImageList是轮播图代码里的内容，接受一个图片链表。</p><p>问题来了，图片多于5张是没问题的，就算是7、8、9张，但由于无论是几张链表结构都是在保持顺序的左移右移的就不担心了，那么平时只加载这个图片链表的前五张就可以了。当然也可以不移动图片链表顺序，换来之的是加载图片的下标要及时更新，现在想想，两种还都可以。</p><p>但图片少于五张的情况没考虑啊！</p><p>好的细细分一下：</p><p>0张：别建轮播图了别建了有什么意义。。。</p><p>1张：别轮播了别轮播了就一张播什么。。。</p><p>2张、3张、4张，诶这个就有问题了，空的地方怎么办？想着直接填充剩下的就好了。</p><p>比如图片只有三张123，那么就自动插入图片12312形成五张图片的效果。但是看到这个顺序最后的那个2没？它的左边是1，右边也是1，所以当它在中间时两边都为1，这样看起来好像不太恰当，所以把列表弄成123123，也就是把原先的图片x2就行了。</p><p>有考虑到两张图片的情况，x2只有四张，那就x3吧。如两张图片12，转化成列表就是121212了。这没有问题。</p><p>至于尾数？肯定就是取余操作啦！那么综上这个设置图片列表函数就是：</p><pre class=" language-c++"><code class="language-c++">void CarouselWidget::setImageList(QList<QImage *> list)&#123;    if (list.count() == 1)&#123;        ui->labelLeftPrepare->hide();        ui->labelLeft->hide();        ui->labelRight->hide();        ui->labelRightPrepare->hide();        currentIndex = 0;        mImageList = list;    &#125;else if (list.count() < 5)&#123;        for (int i = 0; i < list.count()*3; i++)&#123;            mImageList << list.at(i % (list.count()));            currentIndex = list.count()/2;        &#125;    &#125;else&#123;        mImageList = list;    &#125;    initButtons(list.count());    refreshLabelImg();&#125;</code></pre><p>还有图片的比例、分辨率问题，这个qt里面有弄好的就是这个：</p><pre class=" language-c++"><code class="language-c++">QImage scaled(const QSize &s, Qt::AspectRatioMode aspectMode = Qt::IgnoreAspectRatio,Qt::TransformationMode mode = Qt::FastTransformation) const;</code></pre><p>前两个参数一般是写入控件的大小长宽，后面的参数就是选择分辨率适应模式</p><p>看一下有三个：</p><pre class=" language-c++"><code class="language-c++">enum AspectRatioMode &#123;    IgnoreAspectRatio,    KeepAspectRatio,    KeepAspectRatioByExpanding&#125;;</code></pre><p>其实也可以都试一下看一看效果，第一个就是无视原图片比例直接填充满，第二个保持原比例并不超出给的矩形长宽，第三个也是保持长宽比，而且会尽量缩放成给定矩形的最大比例。</p><p>话不多说，还是网图靠谱：</p><p><img src="/carousel-demo-2/aspect.png"></p><p>​                           </p><h4 id="3-鼠标拖动"><a href="#3-鼠标拖动" class="headerlink" title="3.鼠标拖动"></a>3.鼠标拖动</h4><p>目前控制左移右移的只有下面的按钮而已，加一个鼠标拖动吧还是。</p><p>就平时习惯的那样点击然后向左向右拉，只不过正常来说应该在拉的同时图片会移动一点点，拉超过一段距离才移动完全。不过这个动态过程就算了哈哈哈哈不适合，大可不必。。</p><p>这里就加一个mousePressEvent和mouseReleaseEvent模仿拖动事件吧。</p><p>这个就没什么大问题了，都能得到发生事件的鼠标坐标然后判断一下就行了。如：</p><pre class=" language-c++"><code class="language-c++">if (event->button() == Qt::LeftButton && event->pos().y() < mPicLabelWidth)&#123;        pressPoint = event->pos();&#125;</code></pre><p>也要加一点区域判断，就是必须点在哪里才有效果等等。</p><p>​                               </p><h4 id="4-窗口变动"><a href="#4-窗口变动" class="headerlink" title="4.窗口变动"></a>4.窗口变动</h4><p> 额因为label都会在移动的，所以加布局不合适。</p><p>由于没有加布局，所以现在的位置和大小都是定死的。</p><p>想要当随窗口大小变动而变动的时候，就要手动加resizeevent()，这个事件会随着widget窗口大小变动而自动调用。</p><p>在调试的mainwindow添加resizeevent，也就是在轮播图的parent widget中加入：</p><pre class=" language-c++"><code class="language-c++">void MainWindow::resizeEvent(QResizeEvent* size)&#123;    if (carousel)&#123;        carousel->resize(size->size().width(), size->size().width()/3);    &#125;&#125;</code></pre><p>这个resize会调用carousel的resizeevent，而轮播图就需要重新设置一下那五个固定的预备rect的大小位置，重设一下Label和Image，就行了：</p><pre class=" language-c++"><code class="language-c++">void CarouselWidget::resizeEvent(QResizeEvent* size)&#123;    mPicLabelWidth = (this->width() - (mPicIntervals*2)) / 3;    refreshRectSize();    refreshLabelImg();&#125;</code></pre><p>​                                </p><h3 id="Over"><a href="#Over" class="headerlink" title="Over!"></a>Over!</h3><p>结束！拜拜了您内</p>]]></content>
      
      
      
        <tags>
            
            <tag> qt </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的qplugin之——理解理解</title>
      <link href="/qplugin-demo-2/"/>
      <url>/qplugin-demo-2/</url>
      
        <content type="html"><![CDATA[<p>​                                                       </p><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>在CSDN上有一位大佬很详细的写全了qplugin的插件机制</p><p><a href="https://blog.csdn.net/newthinker_wei/article/details/41291811?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&spm=1001.2101.3001.4242">Qt5的插件机制（1）–Qt 框架中的插件加载机制概述</a></p><p>…</p><p>总共还有六篇之多，细细看下来对帮助理解是很有用处的。</p><p>只是大佬说得太详细…剖析得太深入…</p><p>作为菜鸟只能不求甚解，把用到的关键的深入理解一下就完了。</p><h3 id="QPluginLoader"><a href="#QPluginLoader" class="headerlink" title="QPluginLoader"></a>QPluginLoader</h3><p>直面意思，就是加载插件动态库的类，看看大佬里面的描述：</p><blockquote><p>QLibrary 和 QPluginLoader 依赖的’私有数据类’都是 QLibraryPrivate， 一个QLibrary或QPluginLoader的对象都有一个QLibraryPrivate对象，对应一个库或插件；<br>QFactoryLoader 依赖的’私有数据类’是 QFactoryLoaderPrivate ， 但 QFactoryLoaderPrivate 类中又包含了一个QLibraryPrivate列表，这个列表中有多个<br>QLibraryPrivate类型的元素，对应一系列的库或插件；<br>所以可见，QLibraryPrivate是Qt中与库或插件相关的核心数据类，每个库都对应一个QLibraryPrivate对象。</p></blockquote><p>额等等等等，包括下面很多对这个类成员方法的详细解析，最后加载动态库。</p><p>关键来了，用这种方式加载动态库，对编写有什么限制要求？</p><p>​                    </p><h4 id="新建头文件建立库模板"><a href="#新建头文件建立库模板" class="headerlink" title="新建头文件建立库模板"></a>新建头文件建立库模板</h4><pre class=" language-c++"><code class="language-c++">#include <QtPlugin>#include <QWidget>#include <QtGlobal>class  BaseWidget : public QWidget&#123;public:    BaseWidget(QWidget*) &#123;&#125;    virtual ~BaseWidget() &#123;&#125;&#125;;class Q_DECL_EXPORT PluginLibrary&#123;public:    PluginLibrary() &#123;&#125;    virtual ~PluginLibrary() &#123;&#125;    virtual BaseWidget* create(QWidget *parent = nullptr) const = 0;&#125;;Q_DECLARE_INTERFACE(PluginLibrary, "PluginInterface/1.0")</code></pre><p>库模板里只有一个方法create返回库实体，选择返回一个widget，就是说这次插件设计一个widget，加载插件库就能获得widget啦，而widget的设计可以后续在编辑插件库的时候再实现。</p><p>这里用的全都是虚函数，具体的实现就是在插件库里面形成，也就是插件库的类都是这个类的子类。它，是爸爸。</p><p>这边出现了许许多多的宏，根据大佬的深入解析看看：</p><p><strong>Q_DECL_EXPORT：</strong> </p><p>声明了此类导出动态库；</p><p><strong>Q_DECLARE_INTERFACE：</strong></p><blockquote><p>Q_INTERFACES宏也是与qobject_cast相关，没有Q_DECLARE_INTERFACE和Q_INTERFACES这两个宏，就无法对从插件中获取的实例指针进行qobject_cast映射。<br>不过，Q_INTERFACES宏并没有在Qt的源码中定义，他是MOC的菜，MOC会利用这个宏生成一些代码。要注意一点，如果一个头文件或源文件中用到了Q_INTERFACES宏，<br>那么在调用这个宏之前，必须存在一个 Q_DECLARE_INTERFACE宏声明相应的接口（或者包含一个用Q_DECLARE_INTERFACE宏声明了该接口的头文件），MOC会检查这一点，因为它在为Q_INTERFACES宏生成代码时要用到Q_DECLARE_INTERFACE宏的IID参数。</p></blockquote><p>跟后续插件类子类的宏Q_INTERFACES息息相关，让加载时返回qobject_cast&lt;PluginLibrary*&gt;(obj)实体，实现映射。</p><p>参数也有两个，第一个就是类名，第二就是IID，多用处检查库版本。</p><p>​                    </p><h4 id="建立插件库-子类"><a href="#建立插件库-子类" class="headerlink" title="建立插件库 子类"></a>建立插件库 子类</h4><p>根据模板，编写库的时候也要注意编写要求：</p><pre class=" language-c++"><code class="language-c++">class Orcinusorca : public BaseWidget&#123;    Q_OBJECTpublic:    explicit Orcinusorca(QWidget *parent = nullptr);    ~Orcinusorca();private:    Ui::Orcinusorca *ui;&#125;;class OrcinusorcaPlugin: public QObject, public PluginLibrary&#123;    Q_OBJECT    Q_PLUGIN_METADATA(IID "PluginInterface/1.0")    Q_INTERFACES(PluginLibrary)    BaseWidget * create(QWidget *parent =nullptr) const override &#123;return new  Orcinusorca(parent);&#125;&#125;;</code></pre><p>很明显，加载库的时候就调用create函数，在子类中也就新建了一个widget，至于widget是什么样的，可以在ui中慢慢编辑。这就是满满的c++多态思想，一个父类，多个子类，子类们继承的虚函数实现可以是多样的、不同的。</p><p>也是很多宏，不过也是顺应着父类的Q_DECLARE_INTERFACE宏而已：</p><p><strong>Q_PLUGIN_METADATA：</strong></p><p>编辑IID，要和父类版本号保持一致才行；</p><p><strong>Q_INTERFACES：</strong></p><p>也就是上述的映射了。</p><p>​                  </p><h3 id="加载环节"><a href="#加载环节" class="headerlink" title="加载环节"></a>加载环节</h3><p>从代码上看也挺简单易懂的：</p><pre class=" language-c++"><code class="language-c++">    QPluginLoader pluginLoader(libraryPath);    if (!pluginLoader.load())    &#123;        return false;    &#125;    QObject *obj = pluginLoader.instance();    if (!obj)    &#123;        return false;    &#125;    PluginLibrary* pluginLib= qobject_cast<PluginLibrary*>(obj);    if (!pluginLib)    &#123;        delete obj;        return false;    &#125;    BaseWidget * page = pluginLib->create(this);</code></pre><p>传入库的绝对路径，得到一个obj句柄，在映射一下对应类，就可以调用create产生各个库设计的widget，得到widget后续想干嘛再干嘛咯。</p><p>​                                  </p><h3 id="来了！"><a href="#来了！" class="headerlink" title="来了！"></a>来了！</h3><p>因为只是写写demo，就随便做两个库切换一下，在上一节做的界面里，左边是列表，右边用于显示插件库的widget，最终呈现：</p><iframe height="600" width="800" frameborder="no" border="0" src="show.gif"> </iframe>hahaha 是的两个widget几乎没有内容，但有区别就行了吧。<hr><p>后续加了一点点内容，也就加一个页面就结束了吧也就不开新一篇文章了。</p><p>做的也是比较简单，设计一个ui文件放入widget里面去就完了。</p><p><img src="/qplugin-demo-2/ui.png"></p><p>主要是搞了一下布局，统一了一下背景色，放了个图片放了段文字，其他也没什么。</p><p>设计完界面完整一些吧哈哈哈</p><iframe height="900" width="800" frameborder="no" border="0" src="show_2.gif"> </iframe>]]></content>
      
      
      
        <tags>
            
            <tag> qt </tag>
            
            <tag> qplugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的qplugin之——先弄弄图形</title>
      <link href="/qplugin-demo/"/>
      <url>/qplugin-demo/</url>
      
        <content type="html"><![CDATA[<p>​                                 </p><h3 id="Qplugin"><a href="#Qplugin" class="headerlink" title="Qplugin"></a>Qplugin</h3><p>刚开始接触的时候，想着诶不是弄这么多框框架架的东西和多写几个widget不一样吗，后面想想还真不一样，还是得多了解一下。</p><p>插件插件，就是说明他是动态的，热加载的。热加载就是相当于热插拔，比较灵活。</p><p>这次仿着大佬们的框架搞一个，边搞边查资料理解一下吧。</p><p>大概是这样，左边是一个列表，列表的每个条目对应一个插件，插件内容大概就是一个页面，显示在右边的区域里。</p><p>所以第一步还是先把图形弄一弄，额也就是说还扯不上qplugin。</p><p>​                                                  </p><h3 id="建工程咯"><a href="#建工程咯" class="headerlink" title="建工程咯"></a>建工程咯</h3><p>打算用cmake构建啦，图形程序主体在src目录下，其余每个插件各建一个目录。最外层的cmake先写上：</p><pre class=" language-cmake"><code class="language-cmake">cmake_minimum_required(VERSION 3.1.0 FATAL_ERROR)project(qplugin-demo)set(CMAKE_INCLUDE_CURRENT_DIR ON)set(CMAKE_POSITION_INDEPENDENT_CODE ON)set(CMAKE_AUTOMOC ON)set(CMAKE_AUTOUIC ON)set(CMAKE_AUTORCC ON)set(QT_MINIMUM_VERSION "5.7.1")include(GNUInstallDirs)find_package(Qt5Widgets $&#123;QT_MINIMUM_VERSION&#125; REQUIRED)add_subdirectory(src)</code></pre><p>后面在src里面再建立cmakelist文件，建立mainwindow头文件cpp文件ui文件等，走流程走流程。</p><p>编辑ui，先把什么menubar、maintoolbar、statusbar什么的都删掉，留下一个主窗口的widget就行了。</p><p>然后拖一个treeview和一个scrollArea上去，要同时选中两个控件，才能点水平分割布局：</p><p><img src="/qplugin-demo/splitter.png"></p><p>再设置一个外层widget的布局，他们俩就一左一右填满的整个窗体了！</p><p>​                                      </p><h3 id="TreeView"><a href="#TreeView" class="headerlink" title="TreeView"></a>TreeView</h3><p>提起这个控件，就离不开model view delegate三幻神。</p><h4 id="关于view"><a href="#关于view" class="headerlink" title="关于view"></a>关于view</h4><p>唉就随随便便设一下样式表就行了嘛，把treeview各种东西都干掉了，什么左边点击选项，节点设置，双击等等，不太需要：</p><pre class=" language-c++"><code class="language-c++">ui->treeView->setExpandsOnDoubleClick(false);ui->treeView->setEditTriggers(QAbstractItemView::NoEditTriggers);ui->treeView->setAnimated(true);ui->treeView->setHeaderHidden(true);ui->treeView->setItemDelegate(new TagItemDelegate(this));ui->treeView->setRootIsDecorated(false);ui->treeView->setIndentation(0);ui->treeView->setContentsMargins(0, 0, 0, 0);ui->treeView->setStyleSheet("QTreeView&#123;border:none;background: #E0FFFF;&#125;");ui->sidebarWidget->setStyleSheet("QWidget&#123;background:#E0FFFF;&#125;");</code></pre><h4 id="关于model"><a href="#关于model" class="headerlink" title="关于model"></a>关于model</h4><p>就列表每条item有一个字符串的标题数据，用Qt::DisplayRole值就能返回每条item的字符串了，加一个自定义的role存放每一项的高度吧，想着放个空的进去能有分割效果。</p><p>好了这是标题字符串们：</p><pre class=" language-c++"><code class="language-c++">tagList << tr("humpback whale") << tr("orcinus orca") << tr("balaenoptera musculus") << tr("carcharodon carcharias");</code></pre><p>新建个QStandardItem的子类，里面就存着标题和高度的数据，高度默认40，空的就30，上面三条鲸鱼，中间一个空，下面一条大白鲨！把这些字符串全插入！：</p><pre class=" language-c++"><code class="language-c++">for (int i = 0; i < 3; i++) &#123;    TagItem *item = new TagItem(tagList.at(i));    appendRow(item);&#125;TagItem *item = new TagItem("");item->setSelectable(false);item->setEnabled(false);item->setCheckable(false);item->setheight(30);appendRow(item);TagItem *item2 = new TagItem(tagList.at(3));appendRow(item2);</code></pre><p>字符串数据就通过Qt::DisplayRole获取了，而RowHeight这个就是自定义就行了。再编辑获取数据的data函数，model就完成了：</p><pre class=" language-c++"><code class="language-c++">QVariant TagModel::data(const QModelIndex& index, int role/* = Qt::DisplayRole*/) const&#123;    if(!index.isValid()) &#123;        return QVariant();    &#125;    TagItem* item = static_cast<TagItem*>(QStandardItemModel::itemFromIndex(index));    if(item)&#123;        switch(role) &#123;            case RowHeight:            &#123;                return item->height();            &#125;        &#125;    &#125;    return QStandardItemModel::data(index, role);&#125;</code></pre><p>​                             </p><h4 id="关于delegate"><a href="#关于delegate" class="headerlink" title="关于delegate"></a>关于delegate</h4><p>继承QStyledItemDelegate，就是细化处理每一条item了把，函数里的index参数用于定位哪一条item。</p><p>这个虚函数可以设置每一条的高度：</p><pre class=" language-c++"><code class="language-c++">QSize TagItemDelegate::sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const</code></pre><p>这个虚函数可以细画每一条item里的数据，但当决定要自己写这个paint（瞅一眼const QStyleOptionViewItem &amp;option这个参数心里默默知道要干嘛了吧），就要把项目里的内容都好好画，包括什么item的矩形（option-&gt;rect），item的文本，item的状态（option-&gt;state）等，不然就是空的。要不就不重写也行：</p><pre class=" language-c++"><code class="language-c++">void TagItemDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const</code></pre><p>而获取每一条item的文本和高度这样获取（高度是自己弄的）：</p><pre class=" language-c++"><code class="language-c++">QString title = index.data(Qt::DisplayRole).toString();int height = index.data(RowHeight).toInt();</code></pre><p> 有了这些，就自己咋画就咋画吧。</p><p>​                                           </p><h3 id="我好了"><a href="#我好了" class="headerlink" title="我好了"></a>我好了</h3><p>mainwindow构建好ui后set一下model就好了：</p><pre class=" language-c++"><code class="language-c++">model = new TagModel(this);ui->treeView->setModel(model);</code></pre><p>然后图形出来了：</p><p><img src="/qplugin-demo/pic.png"></p><p>主要看左边，那是一个treeview。treeview弄好了后面随便加节点数据啦哈哈哈。</p>]]></content>
      
      
      
        <tags>
            
            <tag> qt </tag>
            
            <tag> qplugin </tag>
            
            <tag> treeview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于qmenu的样式</title>
      <link href="/qmenu-radius/"/>
      <url>/qmenu-radius/</url>
      
        <content type="html"><![CDATA[<p>​                              </p><h3 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h3><p>最近某知名手机品牌logo修了修圆角，费用200w。。。</p><p>圆角前途一片光明，最近就看看qmenu的圆角。</p><p>​                              </p><h3 id="qss"><a href="#qss" class="headerlink" title="qss"></a>qss</h3><p>那肯定就是改改控件的stylesheet了，找找资料看看关于stylesheet的圆角配置以及其他的，熟悉了某些属性，配好就OK啦。</p><p>最终就配成酱紫：</p><pre class=" language-c++"><code class="language-c++">   QString qss = "QMenu&#123;    background-color: rgb(255, 255, 255);\                            border: 2px solid #2c9dfc; \                            border-radius: 10px; &#125;"                "QMenu::item &#123;  background-color: transparent; \                                border-radius: 5px; \                                padding:8px 25px; \                                margin:2px 2px;  &#125;"                "QMenu::item:selected &#123; background-color: #2c9dfc;&#125;";</code></pre><p>其中前缀就是区分项目各自的样式了，QMenu就是整体，QMenu::item就是菜单上的每一项，QMenu::item:selected就是鼠标聚焦每一项时的样式设置了。</p><p>background-color背景颜色；</p><p>border设置边框，后续跟着的是边框宽2px， solid实线， 颜色；</p><p>border-radius就是设置圆角大小了；</p><p>接下来的Item样式主要是内外边距的理解，那么先把颜色改改，把距离改大可以明显一点：</p><pre class=" language-c++"><code class="language-c++">"QMenu::item &#123;  background-color: red; \                                border-radius: 5px; \                                padding: 20px 10px; \                                margin:40px 20px;  &#125;"</code></pre><p><img src="/qmenu-radius/margin-padding.svg"></p><p>先把每一项的item渲染成红色，所以红色的是item的大小，蓝色边框的白色区域则是整个qmenu的大小；</p><p>margin：简称外边距，可以看到是item的外边框与qmenu的边框的距离和item之间的外边框的距离（唉绕来绕去其实就是外边外边，不理红色里边，把红色当成一个整体，这个红色外边的距离），如果写一个参数，则长和宽都是这个距离，如果写两个参数，则第一个是上和下的距离，第二个是左和右；</p><p>padding：简称内边距，这时就不管外边了，只看红色里边，里边内容（这里是文本）和边框的距离。</p><p>至于item:select，就设一下背景颜色就好了；</p><p>​                            </p><h3 id="圆角-1"><a href="#圆角-1" class="headerlink" title="圆角"></a>圆角</h3><p>再刚刚的设置里，qmenu背景是白色的，而mainwindow背景也是白色的，所以看不出有一个大问题：设置圆角并不会限制qmenu的整体大小。</p><p>qmenu还是一个矩形，所以当背景弄成黑色时，就可以看到边角的白色背景：</p><p><img src="/qmenu-radius/radius-outline.png"></p><p>所以得把qmenu的背景透明才行：</p><pre class=" language-c++"><code class="language-c++">pop_menu->setAttribute(Qt::WA_TranslucentBackground);</code></pre><p>​                               </p><h3 id="准备暴富"><a href="#准备暴富" class="headerlink" title="准备暴富"></a>准备暴富</h3><p>有什么圆角活请call我。谢谢。</p><iframe height="500" width="629" frameborder="no" border="0" src="show.gif"> </iframe>]]></content>
      
      
      
        <tags>
            
            <tag> qt </tag>
            
            <tag> qmenu </tag>
            
            <tag> qss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那些年恶心过的脚本 —— 修改用户配置</title>
      <link href="/linux-shell-1/"/>
      <url>/linux-shell-1/</url>
      
        <content type="html"><![CDATA[<p>​                                                         </p><h3 id="背景故事"><a href="#背景故事" class="headerlink" title="背景故事"></a>背景故事</h3><p>这天想换一个压缩软件，装完后发现默认不是它，当然桌面打开方式也支持为此类文件选择默认程序，但比如我为.tar.gz选择了默认打开程序，.zip文件竟然还不是。</p><p>后来查了查这俩文件的mime_type都不同，一个是application/x-compressed-tar，另一个是application/zip。mime_type是什么呢？</p><blockquote><p>MIME的全称是Multipurpose Internet Mail Extensions，即多用途互联网邮件扩展类型。</p><p>这是HTTP协议中用来定义文档性质及格式的标准。IETF RFC 6838，对HTTP传输内容类型进行了全面定义。<br>而 IANA(互联网号码分配机构)是负责管理所有标准MIME类型的官方机构。可以在这里)找到所有的标准MIME。</p><p>服务器通过MIME告知响应内容类型，而浏览器则通过MIME类型来确定如何处理文档。</p><p>MIME的格式：</p><p>type/subtype</p><p>这是一个两级的分类，第一级分类通常包含text，image，audio，video，applications，multipart和message。</p><p>第二级非常多，通俗的理解成第一级的细分。</p></blockquote><p>这linux桌面系统也用mimetypes区别分类，那先别管那么多，目的很简单，就是想安装这个压缩软件rpm包时自动把默认压缩软件变成它。</p><p>​                         </p><h3 id="其实命令就有"><a href="#其实命令就有" class="headerlink" title="其实命令就有"></a>其实命令就有</h3><blockquote><p>[jal@localhost Desktop]$ xdg-mime –help<br>   xdg-mime - command line tool for querying information about<br>   file type handling and adding descriptions for new file types</p><p>Synopsis</p><p>   xdg-mime query { filetype | default } …</p><p>   xdg-mime default application mimetype(s)</p><p>   xdg-mime install [–mode mode] [–novendor] mimetypes-file</p><p>   xdg-mime uninstall [–mode mode] mimetypes-file</p><p>   xdg-mime { –help | –manual | –version }</p><p>Use ‘man xdg-mime’ or ‘xdg-mime –manual’ for additional info.</p></blockquote><p>其中 xdg-mime default application mimetype(s) 就适合这次目的。</p><p>比如xdg-mime default org.kde.ark.desktop application/x-compressed-tar就成功修改了.tar.gz的默认打开程序为ark。</p><p>但是真的要每次装完压缩软件都打开终端敲命令，还一敲敲一堆吗？大哥你是桌面系统诶 = =</p><p>换个法子吧。比如装完包就立即生效就很不错。</p><p>尝试过编辑srpm包中的spec文件的%post区域，即安装后运行N个xdg-mime命令，但还是不行因为rpm安装的时候是以超级用户安装的，这个xdg-mime命令也改的只是root用户的配置，对于普通用户是不生效的。</p><p>但也由此发现，原来有配置文件配置着这一切~/.config/mimeapps.list，瞅一眼这个文件里面一目了然嘛</p><blockquote><p>[Default Applications]<br>x-scheme-handler/http=google-chrome.desktop<br>x-scheme-handler/https=google-chrome.desktop<br>x-scheme-handler/about=google-chrome.desktop<br>x-scheme-handler/unknown=google-chrome.desktop<br>…<br>…<br>…<br>[Added Associations]<br>…<br>…</p></blockquote><p>这个..尝试直接写一个application/zip=org.kde.ark.desktop上去，发现是生效的。</p><p>那就打算直接在spec文件的%post字段执行脚本，改用户配置就行了。</p><p>​                                                </p><h3 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h3><p>脚本这东西，就是你用的时候永远都不记得了的东西。</p><p>那么也尽量做得通用一点。大概的想法是这个脚本要配一个参数，参数就是要设置的默认压缩软件的desktop文件名，脚本里有支持的mimetypes设置，当要增加直接增加即可。</p><p>老规矩先想想，当然这里是马后炮哈哈哈，刚开始想没这么多，都是执行几次后发现不行再补漏，但其实核心也没变多少，补也是补细节罢了。</p><p>​                                                                                </p><h4 id="1-参数过滤"><a href="#1-参数过滤" class="headerlink" title="1.参数过滤"></a>1.参数过滤</h4><p>脚本脚本，都是一边搞一边百度”linux 脚本如何xxx”。。</p><p>这里简单判断下首先参数为一个：</p><pre class=" language-shell"><code class="language-shell">if [ ! $# -eq 1 ] ;then    echo use [cmd] [archive program desktop file]    exit 1 fi</code></pre><p>这里百度到这个$#代表参数个数，不包含脚本自己本身。</p><p>​                </p><p>然后判断下参数是不是dekstop文件：</p><pre class=" language-shell"><code class="language-shell">if [[ ! $1 == *".desktop" ]] ;then    echo not a desktop file    exit 1fi</code></pre><p>这里是百度判断字符串是否包含xxx，这个方法不错。</p><p>用到的是两个中括号，额又百度下大概 [[]] 是 [] 的拓展，比后者强大很多，比如支持正则表达式，这里就用到了正则表达式。</p><p>​                                                                    </p><h4 id="2-扩展支持"><a href="#2-扩展支持" class="headerlink" title="2.扩展支持"></a>2.扩展支持</h4><p>这里肯定是定义数组了，不然下面肯定有一堆重复的代码了，关键只是在shell里面的数组和后续的遍历不太懂，所以又得百度一下。</p><p>好吧定义数组是这样：</p><pre class=" language-shell"><code class="language-shell">support_mime_type=("application/x-tar""application/x-compressed-tar""application/x-xz-compressed-tar""application/x-compressed-tar""application/x-bzip-compressed-tar""application/x-tarz""application/x-cbr""application/vnd.rar""application/x-7z-compressed""application/x-java-archive""application/vnd.comicbook+zip""application/zip""application/x-rpm""image/svg+xml-compressed")</code></pre><p>有数组就有遍历，后续的遍历格式是这样：</p><pre class=" language-shell"><code class="language-shell">for mime_type in $&#123;support_mime_type[*]&#125;do    echo mime_typedone</code></pre><p>​                                                            </p><h4 id="3-修改流程"><a href="#3-修改流程" class="headerlink" title="3.修改流程"></a>3.修改流程</h4><p>最关键就数这里了。</p><p>a）首先找到所有用户，或是说列出所有用户，命令读取多个参数并循环执行可以使用这个办法：</p><pre class=" language-shell"><code class="language-shell">ls /home/ | while read linedo    ...done</code></pre><p>b）判断用户内是否存在.config目录，如果没有那大概率不是一个用户目录，就不执行下去：</p><pre class=" language-shell"><code class="language-shell">if [ -d /home/$line/.config ]; then    echo find /home/$line/.config    ...fi</code></pre><p>c）判断用户是否存在mimeapps.list文件，如果有就说明配置过，直接处理，如果没有就新建一个再进行处理，：</p><pre class=" language-shell"><code class="language-shell">if [ -e /home/$line/.config/mimeapps.list ]; then        echo find /home/$line/.config/mimeapps.list        ...else        echo not find /home/$line/.config/mimeapps.list        touch /home/$line/.config/mimeapps.list        chmod 777 /home/$line/.config/mimeapps.list        echo [Default Applications] >> /home/$line/.config/mimeapps.list        ...fi</code></pre><p>d）有了mimeapps.list这个文件，就直接根据support_mime_type修改这个文件的内容，当然就是sed了。对于已存在mimeapps.list文件的，先判断有没有配置过相关类型默认打开方式，如果有就覆盖掉了，如果没有就加上，所以加起来就是：</p><pre class=" language-shell"><code class="language-shell">for mime_type in $&#123;support_mime_type[*]&#125;do    grep $&#123;mime_type&#125; /home/$line/.config/mimeapps.list > /dev/null    if [ $? -eq 0 ] ;then        echo "find setting $&#123;mime_type&#125;"        sed -i 's#'$&#123;mime_type&#125;'=.*#'$&#123;mime_type&#125;'='$1'#g' /home/$line/.config/mimeapps.list    else        echo not setting $&#123;mime_type&#125;  yet        sed -i '/\[Default Applications\]/a'$&#123;mime_type&#125;'='$1'' /home/$line/.config/mimeapps.list    fidone</code></pre><p>在sed匹配命令里用到变量，要用单引号括起来。额就是字符串里加变量，不然变量就不是变量了就是字符串。</p><p>sed -i ‘s#’${mime_type}’=.*#’${mime_type}’=’$1’#g’ /home/$line/.config/mimeapps.list<br>这里用了井号分割符号，s首先说明了替换，’${mime_type}’就是上面定义的数组，=.*配合前者加起来的被替换内容就是如application/x-tar=.*等等这种，意思就是把application/x-tar=开头的所有内容替换，换成application/x-tar=xxx.desktop，也就是输入参数。</p><p>判断有没有配置过用grep看看文件有没有包含字段就行，有就整行替换了，整行替换用到.*匹配。</p><p>没有的话先匹配[Default Applications]字段，然后在下一行加就行，当然中括号属于特殊字符，前面加个反斜杠表示它是字符串。</p><p>sed -i ‘/[Default Applications]/a’${mime_type}’=’$1’’ /home/$line/.config/mimeapps.list<br>添加sed语法也没什么了。                                            </p><p>先前没有mimeapps.list文件的当然也属于没有配置过，也直接加即可。</p><p>​                                                                           </p><h3 id="OHHHHHHHHHHHHHHHHHHHHHHHHHHHHh"><a href="#OHHHHHHHHHHHHHHHHHHHHHHHHHHHHh" class="headerlink" title="OHHHHHHHHHHHHHHHHHHHHHHHHHHHHh"></a>OHHHHHHHHHHHHHHHHHHHHHHHHHHHHh</h3><p>把脚本放到/usr/bin/下面，改一下权限。</p><p>再运行一下，再看看配置文件mimeapps.list，再在桌面上双击一下试试。</p><p>当然是生效的！</p><p>添加脚本到软件包里，在cmakelist上面添加安装规则</p><pre class=" language-cmake"><code class="language-cmake">install(    FILES set-archiver.sh    DESTINATION "/usr/bin/")</code></pre><p>然后去spec文件的%post字段，也就是安装后执行的命令添加即可：</p><pre class=" language-shell"><code class="language-shell">chmod 777 /usr/bin/set-archiver.sh/usr/bin/set-archiver.sh org.kde.ark.desktop</code></pre><p>​                   </p><p><a href="set-archiver.sh">set-archiver.sh</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绘制svg</title>
      <link href="/paint-svg/"/>
      <url>/paint-svg/</url>
      
        <content type="html"><![CDATA[<p>​                                              </p><h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p>svg是什么呢，是…（百度一下）</p><blockquote><p>SVG是一种图像<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/6156907">文件格式</a>，它的<a href="https://baike.baidu.com/item/%E8%8B%B1%E6%96%87/3079091">英文</a>全称为Scalable Vector Graphics，意思为可缩放的<a href="https://baike.baidu.com/item/%E7%9F%A2%E9%87%8F%E5%9B%BE%E5%BD%A2/1450649">矢量图形</a>。它是基于<a href="https://baike.baidu.com/item/XML/86251">XML</a>（Extensible Markup Language），由World Wide Web Consortium（<a href="https://baike.baidu.com/item/W3C/216888">W3C</a>）联盟进行开发的。严格来说应该是一种开放标准的矢量图形语言，可让你设计激动人心的、高分辨率的Web图形页面。用户可以直接用<a href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81/86048">代码</a>来描绘图像，可以用任何文字处理工具打开SVG图像，通过改变部分代码来使图像具有交互功能，并可以随时插入到<a href="https://baike.baidu.com/item/HTML/97049">HTML</a>中通过浏览器来观看。</p></blockquote><p>哈哈简短的说矢量图，矢量图粗俗点说，就是这张图无论你放多大他还是很清晰的，矢量嘛。</p><p>那么想画矢量图关键就是学着描绘这些矢量了，其中path元素就最基础同时也最多变，path是什么呢，是…（梅开二百度）</p><blockquote><p>path元素是SVG基本形状中最强大的一个，它不仅能创建其他基本形状，还能创建更多其他形状。你可以用path元素绘制矩形（直角矩形或者圆角矩形）、圆形、椭圆、折线形、多边形，以及一些其他的形状，例如贝塞尔曲线、2次曲线等曲线。path元素的形状是通过属性d来定义的，属性d的值是一个“命令+参数”的序列。</p></blockquote><p>​                                                          </p><h3 id="开画"><a href="#开画" class="headerlink" title="开画"></a>开画</h3><p>新建一个文档，就叫rect.svg。</p><p>编写格式是xml格式，所以基本明白一些主要的元素功能就能搞定了。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>230<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>230<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">></span></span></code></pre><p>再定义一个组<g>，组是什么呢，是…（再度）</g></p><blockquote><p>SVG &lt;g&gt;元素用于将SVG形状分组在一起。分组后，您可以像变形单个形状一样变换整个形状。与 不能单独成为转换目标的嵌套 &lt;svg&gt;元素相比，这是一个优势。您还可以设置分组元素的样式，并像对待单个元素一样重复使用它们。</p></blockquote><p>大概像那个&lt;div&gt;？比如在组里定义透明度为1那么组内所有元素透明度都是1.</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>230<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>230<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>g</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">opacity</span><span class="token punctuation">:</span><span class="token number">1</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>g</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">></span></span></code></pre><p>然后开始定义路径了，首先想干嘛呢，想做一个正方形按钮，按钮是圆角的，按钮内有一个正方形框的图案。</p><p>先有一个草图，大概先规划一些比例。</p><p>图片长宽230，四周留空20，按钮长宽就是190了，正方形框图案在按钮正中央，长宽都是90，框长10。</p><p>这些数据很重要，因为后面的path像是在坐标轴上定点连线，这时需要了解一些命令：</p><blockquote><p>M 移动到的点的x轴和y轴的坐标<br>H 绘制平行线<br>V 绘制垂直线<br>Z 关闭路径，回到起点。<br>大写表示绝对定位，小写表示相对定位。</p></blockquote><p>绝对定位，指的是以最左上角为原点的坐标轴定位，相对就是以当前的点作为原点。</p><p>坐标轴，x轴向右，y轴向下。</p><p>外层的这个按钮，可以利用rect元素简单描绘一下：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>230<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>230<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>g</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">opacity</span><span class="token punctuation">:</span><span class="token number">1</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rect</span> <span class="token attr-name">x</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span> <span class="token attr-name">y</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span> <span class="token attr-name">rx</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>22<span class="token punctuation">"</span></span> <span class="token attr-name">ry</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>22<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>190<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>190<span class="token punctuation">"</span></span> <span class="token attr-name">fill</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#e8e8e8<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>g</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">></span></span></code></pre><p>然后就变成了这样</p><p><img src="/paint-svg/svg-1.png"></p><p>接着想一想图案，它90的长宽，那么它的起点应该就在（70，70）这个位置。</p><p>所以先移动：M70 70                     </p><p>已经到这个点了，那么可以使用相对位置了，接着向下画90的直线，再向右画90：</p><p>M70 70 v90 h90</p><p>这时脑海里想着上面是什么，没错那是一个L。然后就向上走啦，当然可以v-90这样写，也可以V70，一个相对一个绝对，但其实都是同一个点。</p><p>最后z，就自动回到起点（70，70），形成一个正方形：</p><p>M70 70 v90 h90 v-90 z</p><p>这时方框的外线，还有一个内线，让框长10，也就是还要画一个长宽70的正方形。因为这个框要填颜色的，所以另起一个路径是不行的，所以在刚那个路径继续画，现在的点在哪？在（70，70），也就是外正方形的左上角，这时想去内正方形的左上角，只需要m10 10即可，然后操作都一样啦：</p><p>M70 70 v90 h90 v-90 z m10 10 h70 v70 h-70 z</p><p>填冲颜色加起来就是：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>230<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>230<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>g</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">opacity</span><span class="token punctuation">:</span><span class="token number">1</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rect</span> <span class="token attr-name">x</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span> <span class="token attr-name">y</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span> <span class="token attr-name">rx</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>22<span class="token punctuation">"</span></span> <span class="token attr-name">ry</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>22<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>190<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>190<span class="token punctuation">"</span></span> <span class="token attr-name">fill</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#e8e8e8<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>path</span> <span class="token attr-name">d</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>M70 70 v90 h90 v-90 z m10 10h70v70h-70z<span class="token punctuation">"</span></span> <span class="token attr-name">fill</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#202020<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>g</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">></span></span></code></pre><p>看起来就是：</p><p><img src="/paint-svg/svg-2.png"></p><p>​                                                              </p><h3 id="OHHHHHHHHHHHHHHHHHHHHHHHHHHH"><a href="#OHHHHHHHHHHHHHHHHHHHHHHHHHHH" class="headerlink" title="OHHHHHHHHHHHHHHHHHHHHHHHHHHH"></a>OHHHHHHHHHHHHHHHHHHHHHHHHHHH</h3><p>关键要理解各个命令，各个元素就其实很简单啦。</p>]]></content>
      
      
      
        <tags>
            
            <tag> svg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为命令添加图形</title>
      <link href="/grdesktop/"/>
      <url>/grdesktop/</url>
      
        <content type="html"><![CDATA[<p>​                                                                      </p><h3 id="小背景"><a href="#小背景" class="headerlink" title="小背景"></a>小背景</h3><p>图形图形，就是为一段程序代码加一层图形。</p><p>通常linux系统中打开终端输入程序命令运行程序，大体上要我们输入命令名称，参数名称，就可达到目的。</p><p>当输入的都知道，就考虑开始加图形界面吧！</p><p>有一个远程连接工具叫rdesktop，基于xorg远程协议，这次就搞搞这个。</p><p>命令很简单，就rdesktop后面加一个ip，参数有很多比如用户名密码全屏分辨率等等，这些数据后面的Qprocess会用到。</p><p>​                        </p><h3 id="Qtcreator走起"><a href="#Qtcreator走起" class="headerlink" title="Qtcreator走起"></a>Qtcreator走起</h3><p>首先新建工程，是个有窗口的工程就第一个，选好东西编辑好文件名，ui文件肯定是需要的，因为它还是很方便的哈哈哈</p><p><img src="/grdesktop/new_pro.png"></p><p>默认的ui有一些menubar等等一些用不到的东西，全都通通删掉留下一个widget窗口即可。</p><p>想想需要什么，只要一个输入框输入ip，一个输入用户名，一个输入密码，分别在3个输入框前面加标签说明输入框输入什么，再加两个按钮分别确定和取消，就是所有需要的内容了。</p><p>考虑完这个就思考布局了，输入框说明标签和输入框肯定是平行的，扔一个label和lineedit上去，选中两个右键选择水平布局就成了这样的：</p><p><img src="/grdesktop/layout_1.png"></p><p>然后需要这样的东西三个，就ctrl c、ctrl v两下，编辑一下标签内容，再拉一个buttonbox上去，这是内容齐了：</p><p><img src="/grdesktop/layout_2.png"></p><p>最后选中最外层的mainwindow，右键选择垂直布局，调整一下输入框的最大长度和最小长度，诶其实相当于固定它的长度对齐一点，诶效果出来了有没有：</p><p><img src="/grdesktop/layout_3.png"></p><p>一般确认和取消按钮和上面内容有一段小空白，就再加一个弹簧：</p><p><img src="/grdesktop/layout_4.png"> </p><p>再运行一下看看效果怎样：</p><p> <img src="/grdesktop/layout_5.png"></p><p>诶，舒服！</p><p>也打算固定这样的大小了，所以没有窗口变大变小的情况，也就不用各种设置弹簧了。mainwindow的windowtitle属性改一改标题名称，诶图形就基本结束了！</p><p>​                                                                 </p><h3 id="后台数据"><a href="#后台数据" class="headerlink" title="后台数据"></a>后台数据</h3><p>首先思考得有层次，虽然说是个很呆的小东西，但是养成习惯嘛</p><p>main文件是运行启动图形app程序的，mainwindow是编辑图形程序的，再加一个grdesktopmodel文件用于处理后台命令运行，就是说所有界面的操作代码在mainwindow中完成，而命令的运行在grdesktopmodel中完成，这是最基本的想法。</p><p>那么先编辑mainwindow图形文件，回到ui文件对着lineedit右键点击go to slot编辑槽函数，选择有一个textChanged相关的槽函数，每次编辑输入框都会触发这个函数。</p><p>然后一看傻眼了槽函数名称自动生成on_lineEdit_4_textChanged。。。</p><p>好吧怪自己没改输入框名，回到ui界面改一下，自动生成的函数全部重新生成吧，头文件那里都全部删掉。</p><p>而bottonbox那里一个accepted一个rejected，分别代表Ok和cancel。</p><p>输入框输入时就检测三个输入框都有没有内容吧，如果都有内容，就让ok使能：</p><pre class=" language-c++"><code class="language-c++">void MainWindow::checkDataCompleted()&#123;    if (ui->lineEditIP->text().isEmpty() || ui->lineEditUserName->text().isEmpty() || ui->lineEditPassWord->text().isEmpty())&#123;        ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(false);    &#125;else &#123;        ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(true);    &#125;&#125;</code></pre><p>​                                       </p><p>而accepted后，就传参进待写的grdesktopmodel类，运行命令程序，基本完成！</p><pre class=" language-c++"><code class="language-c++">void MainWindow::on_buttonBox_accepted()&#123;    this->hide();    model->setUserName(ui->lineEditUserName->text());    model->setIpAddress(ui->lineEditIP->text());    model->setPassWord(ui->lineEditPassWord->text());    model->startProcess();&#125;</code></pre><p>​         </p><p>rejected后，关闭整个程序即可：</p><pre class=" language-c++"><code class="language-c++">void MainWindow::on_buttonBox_rejected()&#123;    this->close();&#125;</code></pre><p>​                               </p><h3 id="QProcess"><a href="#QProcess" class="headerlink" title="QProcess"></a>QProcess</h3><p>在grdesktopmodel文件里新建QProcess类，开始使用它。</p><p>使用很简单，第一个参数是命令字符串，第二个就是参数列表，把参数组成QStringList传进去即可：</p><pre class=" language-c++"><code class="language-c++">void MainWindow::startProcess()&#123;    QStringList argsList;    argsList << "-I" << m_ip << "-u" << m_userName << "-p" << m_passWord;    if (m_process)&#123;        m_process->start("rdesktop", argsList);        m_process->waitForFinished();    &#125;&#125;</code></pre><p>而start和startDetached，后者名为分离式启动，可以简单点理解成后者启动程序的话该启动程序就不受这个界面app控制了。那如果还是想处理一下程序报错等，还是选择前者吧。</p><p>出错或者提醒的时候，也要图形化一下的，加个槽连接：</p><pre class=" language-c++"><code class="language-c++">connect(m_process , SIGNAL(readyReadStandardError()) , this , SLOT(onReaderror()));</code></pre><p>而在onReaderror函数里，就直接调用QMessageBox类在桌面弹出提醒框：</p><pre class=" language-c++"><code class="language-c++">QMessageBox::information(0, tr("Error"), m_process->readAllStandardError().data());</code></pre><p>而提醒内容也能读到。</p><p>​                                   </p><h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><p>额加不加也无所谓，修改一下pro文件或cmakelist.txt文件生成翻译文件后，可以选择在main文件里加载翻译文件。</p><p>只不过得注意要在图形类构造前先加载翻译：</p><pre class=" language-c++"><code class="language-c++">    QApplication a(argc, argv);    // load translations    // install the translations built-into Qt itself    QTranslator qtTranslator;    qtTranslator.load(QStringLiteral("qt_") + QLocale::system().name(), QLibraryInfo::location(QLibraryInfo::TranslationsPath));    a.installTranslator(&qtTranslator);    // install our own tranlations    QTranslator translator;    translator.load(QStringLiteral("grdesktop_") + QLocale::system().name(), QStringLiteral(GRDESKTOP_DATA_DIR) + QStringLiteral("/translations"));    a.installTranslator(&translator);    MainWindow w;    w.show();</code></pre><p>​                                      </p><h3 id="OHHHHHHHHHHHHHHHH"><a href="#OHHHHHHHHHHHHHHHH" class="headerlink" title="OHHHHHHHHHHHHHHHH"></a>OHHHHHHHHHHHHHHHH</h3><p>就跑一跑，诶随便输报错也有提醒框，就很舒服。</p><p><img src="/grdesktop/err.png"></p><p>当然都输入对的话就能远程控制桌面啦。</p><p>只要服务端开启xorg协议，防火墙没阻止，这个rdesktop软件还是能跑的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> qt </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ftp配置（linux系统）</title>
      <link href="/linux-ftp-config/"/>
      <url>/linux-ftp-config/</url>
      
        <content type="html"><![CDATA[<p>​                   </p><h4 id="下载vsftpd"><a href="#下载vsftpd" class="headerlink" title="下载vsftpd"></a>下载vsftpd</h4><p>sudo yum install vsftpd</p><p>​                            </p><h4 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h4><p>vim /etc/vsftpd/vsftpd.conf</p><p>​                               </p><h5 id="取消注释或更改配置："><a href="#取消注释或更改配置：" class="headerlink" title="取消注释或更改配置："></a>取消注释或更改配置：</h5><p>anonymous_enable=YES             允许匿名</p><p>anon_upload_enable=YES           允许匿名上传</p><p>anon_mkdir_write_enable=YES    允许匿名创建目录</p><p>​                                      </p><h5 id="添加配置："><a href="#添加配置：" class="headerlink" title="添加配置："></a>添加配置：</h5><p>anon_umask=022                            匿名上传权限掩码<br>anon_root=/var/ftp                            匿名ftp根目录<br>anon_other_write_enable=YES        匿名其他读写权限<br>anon_max_rate=0                            不限知速率</p><p>​                                       </p><h4 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h4><p>systemctl restart vsftpd</p><p>​                                  </p><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>tags:解除一下sellinux限制 sudo setsebool -P allow_ftpd_full_access on</p><p>​                                          </p><h5 id="匿名"><a href="#匿名" class="headerlink" title="匿名"></a>匿名</h5><p>正常来说已经可以下载文件了，使用匿名登录可访问下载服务器/var/ftp/pub上的文件。</p><p>可上传还是有问题，需要服务器改变文件夹权限：sudo chmod 777 /var/ftp/pub，就可上传文件到服务器和一些写文件操作了。</p><h5 id="非匿名"><a href="#非匿名" class="headerlink" title="非匿名"></a>非匿名</h5><p>可正常运行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ftp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识qml——PathView QQmlContext c++类与qml的数据交互</title>
      <link href="/pathview-demo-3/"/>
      <url>/pathview-demo-3/</url>
      
        <content type="html"><![CDATA[<a class="theme-btn" href="https://blog.csdn.net/weixin_38627652" title="outline blue larger"><i class="far fa-hand-point-right"></i>去我的csdn博客看看呗</a><a class="theme-btn" href="https://nightcivet.site/pathview-demo/" title="outline blue larger"><i class="far fa-hand-point-right"></i>初识qml——PathView初理解</a><a class="theme-btn" href="https://nightcivet.site/pathview-demo-2/" title="outline blue larger"><i class="far fa-hand-point-right"></i>初识qml——PathView xyz轴 路径属性 旋转效果 鼠标键盘控制</a><hr><p>​                                                 </p><h3 id="数据数据"><a href="#数据数据" class="headerlink" title="数据数据"></a>数据数据</h3><p>要展示的数据如果是复杂点的，通过代码控制获取的，那肯定就不能是在qml中定义几串字符串那么简单了。</p><p>这时就可以编辑QAbstractListModel实现代码和qml中数据通信。</p><p>先想好数据类型，每个delegate需要一个图片地址，再加一个图片介绍吧。所以是一个链表，链表上的每个数据是两个字符串。</p><p>所以数据是这样：</p><pre class=" language-c++"><code class="language-c++">typedef  struct dataMeta&#123;    QString url;    QString info;&#125;m_data;typedef  QList<m_data> datalist;</code></pre><p>然后整个类说白了就是服务于这条链表，在类里面定义的私有变量datalist dataList;                                    </p><p>​                                            </p><h3 id="照着框架写"><a href="#照着框架写" class="headerlink" title="照着框架写"></a>照着框架写</h3><p>建立QAbstractListModel的子类，写好数据，当然数据还是挺简单的哈哈哈，但总有一天会有复杂的时候：</p><pre class=" language-c++"><code class="language-c++">dataModel::dataModel(QObject *parent):QAbstractListModel(parent)&#123;    QStringList infotemp;    infotemp << "不知火曾经是离岛闻名天下的歌姬阿离，有着绝美的容颜。在一个即将失去生命的夜晚，她成为了大妖怪不知火。"             << "彼岸花是居住在冥界的妖怪，外表美艳动人，性格却难以捉摸。她常常出现在三途川边的彼岸花海中。虽然她曾经在人界生活过，但却很少提起自己的过去。"             << "曾经被称为“曜姬”的少女，如今却隐于夜幕之下。她昔日视为神明的女王，已失去了太阳的辉光。"             << "鬼切原是大江山之鬼，后被源赖光以自己的血为媒介封入守护刀，左眼被植入封闭记忆的契约。他在大江山、罗生门一战中记忆因妖气逐渐复苏，并开始向源赖光复仇。"             << "少羽大天狗为天狗一族，为身后孱弱的羽翼而感到自卑，渴望飞上群山之巅，内心却一直回响着消极的声音。终于在神秘的笛音中获得了内心坚定的力量，燃起内心的勇气，向崇天高云的风景发起了挑战，也回忆起自己的少年幼时。";    for (int i = 0; i < 5; i++)&#123;        m_data datatemp;        datatemp.url = QString("qrc:/%1.jpg").arg(i+1);        datatemp.info = infotemp.at(i);        dataList << datatemp;   &#125;&#125;</code></pre><p> 后面实现好框架定好的三个虚函数，就可以接入qml了。</p><p>​                                   </p><h4 id="QHash-lt-int-QByteArray-gt-roleNames-const"><a href="#QHash-lt-int-QByteArray-gt-roleNames-const" class="headerlink" title="QHash&lt;int, QByteArray&gt; roleNames() const"></a>QHash&lt;int, QByteArray&gt; roleNames() const</h4><p>listmodel是类似键-键值的结构，这个函数需要写的就是键值名：</p><pre class=" language-c++"><code class="language-c++">QHash<int, QByteArray> dataModel::roleNames() const &#123;    QHash<int, QByteArray> roleNames;    roleNames[UrlRole] = QByteArrayLiteral("url");    roleNames[InfoRole] = QByteArrayLiteral("info");    return roleNames;&#125;</code></pre><p>当然它用了hash数据结构，也不用自己操作什么，要做的就是定义好键名“url”和“info”。</p><p>而对应的第几个用一个枚举包含着，后续会用到：</p><pre class=" language-c++"><code class="language-c++">enum dataRole &#123;    UrlRole = Qt::UserRole + 1,    InfoRole&#125;;</code></pre><p>​                                                                                  </p><h4 id="int-rowCount-const-QModelIndex-amp-parent-QModelIndex-const"><a href="#int-rowCount-const-QModelIndex-amp-parent-QModelIndex-const" class="headerlink" title="int rowCount(const QModelIndex &amp;parent = QModelIndex()) const"></a>int rowCount(const QModelIndex &amp;parent = QModelIndex()) const</h4><p>这个函数是计算数据的数量，返回链表的长度即可。</p><pre class=" language-c++"><code class="language-c++">int dataModel::rowCount(const QModelIndex &parent) const &#123;    return dataList.count();&#125;</code></pre><p>要在pathview用到这个数据可以加一个Q_PROPERTY实现：</p><pre class=" language-c++"><code class="language-c++">Q_PROPERTY(int count READ rowCount CONSTANT)</code></pre><p>​                                                      </p><h4 id="QVariant-data-const-QModelIndex-amp-index-int-role-Qt-DisplayRole-const"><a href="#QVariant-data-const-QModelIndex-amp-index-int-role-Qt-DisplayRole-const" class="headerlink" title="QVariant data(const QModelIndex &amp;index, int role = Qt::DisplayRole) const"></a>QVariant data(const QModelIndex &amp;index, int role = Qt::DisplayRole) const</h4><p>这个虚函数就是返回键值的时候了，role定位刚刚定义的枚举，index是model数据链表的第几个，定义好数据返回即可，千篇一律：</p><pre class=" language-c++"><code class="language-c++">QVariant dataModel::data(const QModelIndex &index, int role) const &#123;    if (index.row() < 0 || index.row() >= dataList.count())        return QVariant();    switch (role) &#123;    case UrlRole:        return dataList.at(index.row()).url;    case InfoRole:        return dataList.at(index.row()).info;    default:        break;    &#125;    return QVariant();&#125;</code></pre><p>​                               </p><h3 id="接入"><a href="#接入" class="headerlink" title="接入"></a>接入</h3><p>在quickview构造之后立刻传入即可，构造写好的dataModel并按照指针传入，并定义好标识名datamodel，qml里就可以使用这个名字了：</p><pre class=" language-c++"><code class="language-c++">view->rootContext()->setContextProperty(QStringLiteral("datamodel"), model);</code></pre><p>qml里PathView的model可以选定为datamodel。</p><p>加一个Text段，用于显示图片介绍，首先先建立delegate的文本变量接住model的info变量：</p><pre class=" language-qml"><code class="language-qml">property string infoText: info</code></pre><p>后续编辑Text的时候可以pathView.currentItem定位到当前delegate，显示对应文本了。</p><p>弄好位置，发现文本不换行，网上查定义了wrapMode的很多种换行模式<a href="https://blog.csdn.net/ZefinNg/article/details/106436014">Qml中的Text控件</a>，这里就随便选一种了。</p><pre class=" language-qml"><code class="language-qml">Text&#123;    anchors.left: pathView.left    anchors.leftMargin: root.width/5    anchors.bottom: root.bottom    anchors.bottomMargin: 120    width: pathView.width*3/5    height: 80    opacity: 0.7    text: pathView.currentItem.infoText    color: "white"    font.pixelSize: 22    wrapMode: Text.WrapAnywhere&#125;</code></pre><p>​                                          </p><h3 id="恭喜！"><a href="#恭喜！" class="headerlink" title="恭喜！"></a>恭喜！</h3><p>数据是接入成功滴：</p><iframe height="600" width="800" frameborder="no" border="0" src="demo.gif"> </iframe><p><a href="main.qml">main.qml</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> qt </tag>
            
            <tag> c++ </tag>
            
            <tag> qml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识qml——PathView xyz轴 路径属性 旋转效果 鼠标键盘控制</title>
      <link href="/pathview-demo-2/"/>
      <url>/pathview-demo-2/</url>
      
        <content type="html"><![CDATA[<a class="theme-btn" href="https://blog.csdn.net/weixin_38627652" title="outline blue larger"><i class="far fa-hand-point-right"></i>去我的csdn博客看看呗</a><a class="theme-btn" href="https://nightcivet.site/pathview-demo/" title="outline blue larger"><i class="far fa-hand-point-right"></i>初识qml——PathView初理解</a><a class="theme-btn" href="https://nightcivet.site/pathview-demo-3/" title="outline blue larger"><i class="far fa-hand-point-right"></i>初识qml——PathView QQmlContext c++类与qml的数据交互</a><hr><p>​                                                                        </p><h3 id="不可能"><a href="#不可能" class="headerlink" title="不可能"></a>不可能</h3><p>pathview弄出来就这效果是不能接受的，所以继续往下，基本流程清楚后开始花里胡哨起来！</p><p>​                                                                             </p><h3 id="先理解"><a href="#先理解" class="headerlink" title="先理解"></a>先理解</h3><p>还是先理解做法的理念，这次找到这位大佬的demo <a href="https://blog.csdn.net/luoyayun361/article/details/77659386">QML实现酷炫的 Cover Flow 效果（PathView）</a> ，概括起来为pathview添加部分效果，目的是为了好看：</p><ol><li>展示分了层次，有一种前面和后面的层次，这就是z轴。</li><li>大小也有层次，最前面展示的最大，形成动态感。</li><li>各个目标有一定程度的翻转，看起来更立体。</li><li>出现倒影效果</li></ol><p>​                                                                     </p><h4 id="PathAttribute"><a href="#PathAttribute" class="headerlink" title="PathAttribute"></a>PathAttribute</h4><p>在Path的每个点后，可以自定义一些数据，这些数据可以应用于当前点的delegate。ok那每个点后添加三个属性，分别应用于后续使用的z轴，旋转角度和缩放大小：</p><pre class=" language-qml"><code class="language-qml">Path&#123;    id:pathview_path    startX: root.width*2/7    startY: root.height/3    PathAttribute&#123;name:"picZ";value: 0&#125;    PathAttribute&#123;name:"picAngle";value: 50&#125;    PathAttribute&#123;name:"picScale";value: 0.6&#125;    PathLine&#123;x:root.width/2;y:root.height/3&#125;    PathAttribute&#123;name:"picZ";value: 100&#125;    PathAttribute&#123;name:"picAngle";value: 0&#125;    PathAttribute&#123;name:"picScale";value: 1.0&#125;    PathLine&#123;x:root.width*5/7;y:root.height/3&#125;    PathAttribute&#123;name:"picZ";value: 0&#125;    PathAttribute&#123;name:"picAngle";value: -50&#125;    PathAttribute&#123;name:"picScale";value: 0.6&#125;&#125;</code></pre><p>设置后，delegate中可通过PathView.picZ等来访问当前点的这个数据。而点与点之间的点的数据底层会自动计算逐步的递增或递减，就不用自己再定义了。</p><p>​                                                                                                                                              </p><h4 id="Z轴"><a href="#Z轴" class="headerlink" title="Z轴"></a>Z轴</h4><p>z轴大概就是垂直于电脑屏幕的轴线，z轴值越大，就等于离看这电脑屏幕的你越近。</p><p>在delegate的Item里添加z:PathView.picZ属性和数据即可。</p><p>可以看到，中间的点的z轴数据是100，两边的是0。</p><p>​                                                                       </p><h4 id="大小和翻转"><a href="#大小和翻转" class="headerlink" title="大小和翻转"></a>大小和翻转</h4><p>大小简单，用scale属性可以控制大小：scale:PathView.picScale。</p><p>而翻转就复杂很多，先设置变量接住设置的翻转角度属性：property int angle1: PathView.picAngle</p><p>为delegate添加翻转效果，使用transform: Rotation组件，通过设置原点的旋转轴和角度，就形成了旋转的效果。</p><pre class=" language-qml"><code class="language-qml">transform: Rotation&#123;    origin.x:image.width/2.0    origin.y:image.height/2.0    axis&#123;x:0;y:1;z:0&#125;    angle: angle1&#125;</code></pre><p>这个通过官网文档可以理解一点 <a href="https://doc.qt.io/qt-5/qml-qtquick-rotation.html">Rotation QML Type</a></p><p>而这个图和解释，就挺一目了然的：</p><p><img src="/pathview-demo-2/xyz.png"></p><p>​                                                                                                                 </p><h4 id="倒影效果"><a href="#倒影效果" class="headerlink" title="倒影效果"></a>倒影效果</h4><p>先设好图片，右键资源文件目录qml.qrc有一个Open in Editor选项，里面选择Add添加图片进资源文件备用。</p><p>加载图片需要路径，这次的listmode的数据为图片的路径：</p><pre class=" language-qml"><code class="language-qml">ListModel &#123;    id:datamodel;    ListElement &#123;url:"qrc:/1.jpg";&#125;    ListElement &#123;url:"qrc:/2.jpg";&#125;    ListElement &#123;url:"qrc:/3.jpg";&#125;    ListElement &#123;url:"qrc:/4.jpg";&#125;    ListElement &#123;url:"qrc:/5.jpg";&#125;&#125;</code></pre><p>后面在delegate里添加图片，由于有图片翻转了会出现一定的锯齿，添加抗锯齿属性antialiasing：</p><pre class=" language-qml"><code class="language-qml">Image&#123;    id:image    antialiasing: true    source: url    width: mydelegate.width    height: mydelegate.height&#125;</code></pre><p>添加倒影是在图片的正下方再画一个倒立的图片即可，这边怎么实现的就不去追究了，直接拿大佬的：</p><pre class=" language-qml"><code class="language-qml">ShaderEffect &#123;    id: effectImage    anchors.top: image.bottom    width: image.width    height: image.height;    anchors.left: image.left    property variant source: image;    property size sourceSize: Qt.size(0.5 / image.width, 0.5 / image.height);    fragmentShader:    "varying highp vec2 qt_TexCoord0;    uniform lowp sampler2D source;    uniform lowp vec2 sourceSize;    uniform lowp float qt_Opacity;    void main() &#123;        lowp vec2 tc = qt_TexCoord0 * vec2(1, -1) + vec2(0, 1);        lowp vec4 col = 0.25 * (texture2D(source, tc + sourceSize) + texture2D(source, tc- sourceSize)        + texture2D(source, tc + sourceSize * vec2(1, -1))        + texture2D(source, tc + sourceSize * vec2(-1, 1)));        gl_FragColor = col * qt_Opacity * (1.0 - qt_TexCoord0.y) * 0.2;    &#125;"&#125;</code></pre><p>​                                                                                                         </p><h4 id="鼠标键盘"><a href="#鼠标键盘" class="headerlink" title="鼠标键盘"></a>鼠标键盘</h4><p>pathview是没有集成鼠标点击事件的，就是点击项目是不会切换到那个项目，只能鼠标拖动。</p><p>所以在delegate中添加鼠标点击，集成这个效果吧：</p><pre class=" language-qml"><code class="language-qml">MouseArea&#123;    anchors.fill: parent    onClicked: &#123;        pathView.currentIndex = index;    &#125;&#125;</code></pre><p>同理添加一下键盘控制，一开始发现怎么都不生效，后来发现是得先让pathview聚焦才行：</p><pre class=" language-qml"><code class="language-qml">focus: true;Keys.onLeftPressed: decrementCurrentIndex();Keys.onRightPressed: incrementCurrentIndex();Keys.onTabPressed: incrementCurrentIndex();</code></pre><p>​                                                                                                                  </p><h4 id="中间突出"><a href="#中间突出" class="headerlink" title="中间突出"></a>中间突出</h4><p>最后把设置一下无论鼠标怎么拖动，突出的只有一个项目，术语叫期待选定项位位置，让当前选定的项位在路径的中间，这样无论怎么拖动都有一个固定在中间了：</p><pre class=" language-qml"><code class="language-qml">preferredHighlightBegin: 0.5preferredHighlightEnd: 0.5</code></pre><p>​                                                                                                  </p><h3 id="我们不一样！"><a href="#我们不一样！" class="headerlink" title="我们不一样！"></a>我们不一样！</h3><p>曾经的我很丑，但也只是曾经。</p><iframe height="400" width="800" frameborder="no" border="0" src="demo.gif"> </iframe>​                                           <p><a href="main.qml">main.qml</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> qt </tag>
            
            <tag> c++ </tag>
            
            <tag> qml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识qml——PathView初理解</title>
      <link href="/pathview-demo/"/>
      <url>/pathview-demo/</url>
      
        <content type="html"><![CDATA[<a class="theme-btn" href="https://blog.csdn.net/weixin_38627652" title="outline blue larger"><i class="far fa-hand-point-right"></i>去我的csdn博客看看呗</a><a class="theme-btn" href="https://nightcivet.site/pathview-demo-2/" title="outline blue larger"><i class="far fa-hand-point-right"></i>初识qml——PathView xyz轴 路径属性 旋转效果 鼠标键盘控制</a>  <a class="theme-btn" href="https://nightcivet.site/pathview-demo-3/" title="outline blue larger"><i class="far fa-hand-point-right"></i>初识qml——PathView QQmlContext c++类与qml的数据交互</a><hr><p>​                                                                                                                                                  </p><h3 id="直接PathView"><a href="#直接PathView" class="headerlink" title="直接PathView"></a>直接PathView</h3><p>正常来说，应该从头到尾，类似当初从头文件到类型到语法等等学习语言一样了解qml才对，不过才没有这个机会。</p><p>那就直接看代码，通过对代码的嗅觉以及度娘的鼎力相助快速了解这究竟是什么东西。</p><p>好吧，并不是简单的label，button，一上来直接pathview。</p><p>​                                                 </p><h3 id="查查查"><a href="#查查查" class="headerlink" title="查查查"></a>查查查</h3><p>和平时不一样了，平时看着模板再理解代码很是ok，不过这个东西实在需要理论支持，得查阅文档才行。</p><p>先是这大概是一个动态的数据展示方式，沿着路径展示数据。</p><p>暂时有一个快速的理解：PathView必要三要素，path、model、delegate。只要先弄好这三个东西就差不多了。</p><h4 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h4><p>路径，听说还有好几种路径可以选择，各种数学的味道扑面而来，而我选择直线。</p><h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><p>呃模型？理解为就是放数据的。</p><h4 id="Delegate"><a href="#Delegate" class="headerlink" title="Delegate"></a>Delegate</h4><p>呃代理？理解为承载数据的载体，就是这个载体在路径上逐个显示，具体这是个什么自己定义。</p><p>​                                        </p><h3 id="可以动手了"><a href="#可以动手了" class="headerlink" title="可以动手了"></a>可以动手了</h3><h4 id="新建qml工程"><a href="#新建qml工程" class="headerlink" title="新建qml工程"></a>新建qml工程</h4><p>选择一个qml的工程新建，后续选择用cmake构建系统，比较熟悉cmake吧。</p><p><img src="/pathview-demo/new_project.png"></p><p>编辑main.cpp，不用默认的QQmlApplicationEngine改用QQuickView，谁让demo都是quickview呢。对应的main.qml中就不用必须建立window组件了。</p><p>加上&lt;QQuickView&gt;头文件，main.cpp是这样：</p><pre class=" language-c++"><code class="language-c++">#include <QGuiApplication>#include <QQmlApplicationEngine>#include <QQuickView>int main(int argc, char *argv[])&#123;    QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);    QGuiApplication app(argc, argv);    QQuickView *view = new QQuickView;    const QUrl url(QStringLiteral("qrc:/main.qml"));    view->setSource(url);    view->show();    return app.exec();&#125;</code></pre><h4 id="编辑qml"><a href="#编辑qml" class="headerlink" title="编辑qml"></a>编辑qml</h4><p>接下来的所有时间，都是在编辑qml了。</p><p>实在感谢这个网上大兄弟的贡献，找了这么多就这个最通俗易懂，并且能跑起来：</p><p><a href="https://blog.csdn.net/RGBMarco/article/details/81146075?utm_source=blogxgwz0">QML PathView+实战</a></p><p>当然这个大佬还是比较深入了，xyz轴都开始安排上了，我才刚开始就直接屏蔽掉了。好吧就直接开始理解并尝试了。</p><p>ok就直接创建一个Rectangle矩形作为窗体，作为demo的开始：</p><pre class=" language-qml"><code class="language-qml">import QtQuick 2.11Rectangle &#123;    width:600;    height:600;    id:root;    color: "black"&#125;</code></pre><h6 id="ListModel"><a href="#ListModel" class="headerlink" title="ListModel"></a>ListModel</h6><p>首当其冲就是数据了，在qml中数据为ListModel，也可以通过编辑c++的QAbstractListModel类再进行数据传递，后者可以通过代码获取或者创造一些复杂一点的数据。而现在就先直接在qml随便新建一些随便的数据先吧，在矩形窗体里面添加：</p><pre class=" language-qml"><code class="language-qml">ListModel &#123;        id:datamodel;        ListElement &#123;name:"blala小魔仙";&#125;        ListElement &#123;name:"晴明大人";&#125;        ListElement &#123;name:"我妻有乃";&#125;        ListElement &#123;name:"米豆子";&#125;    &#125;</code></pre><p>四条数据，每条数据有一个name属性；</p><h6 id="PathView"><a href="#PathView" class="headerlink" title="PathView"></a>PathView</h6><p>这个是主角没错了，简单的写成这样：</p><pre class=" language-qml"><code class="language-qml">PathView &#123;    anchors.fill:parent;    //锚点设置和外面那层一样大    delegate:mydelegate;    //代理设置为mydelegate，等会编辑这个代理    model:datamodel;        //设置刚刚写下的数据，接入id    pathItemCount:3            //每次展示的数据有3个    path:pathview_path        //设置路径为pathview_path，等会编辑这个路径&#125;</code></pre><h6 id="Delegate-1"><a href="#Delegate-1" class="headerlink" title="Delegate"></a>Delegate</h6><p>Delegate和model是绑定在一起的，也不用去管model中数据的下标，毕竟代理也是根据model的数量创造多个的，用的时候只需要填写model的属性即可，比如根据datamodel这里会创建4个代理，把model的属性写在代理里面即可，底层会自动处理下标（第几条对应第几个啥的），就不用费心了。</p><pre class=" language-qml"><code class="language-qml">Component &#123;    id:mydelegate;    Rectangle &#123;        width:100;        height:100;        color:"white";        opacity: 0.6        Text &#123;            text:name;        &#125;    &#125;&#125;</code></pre><h6 id="Path-1"><a href="#Path-1" class="headerlink" title="Path"></a>Path</h6><p>path规定了动态展示中动态的路径，可以先以整个窗口的左上角为原点建立一个座标轴，根据座标定义开始的位置以及后面的位置，</p><pre class=" language-qml"><code class="language-qml">Path&#123;    id: pathview_path    startX: 100;    startY: root.height / 2;    PathLine &#123;x:root.width / 2;y:root.height / 2;&#125;    PathPercent &#123;value:0.5&#125;    PathLine &#123;x:root.width - 50;y:root.height / 2;&#125;    PathPercent &#123;value:1&#125;&#125;</code></pre><p>这里定义了三个点(100,root.height/2)，(root.width / 2,root.height / 2)，(oot.width - 50,root.height / 2)，以这三个点为原点建立固定的delegate，剩下的会根据显示数量pathItemCount和设置的PathPercent自动分配处理。</p><p><img src="/pathview-demo/path.png"></p><p>比如上面定义的就是从第一个点到第二个点，完成显示pathItemCount的百分之50，再到下一个点就百分百了。</p><p>当然关键的还是每个点都能设置属性PathAttribute，反馈到delegate中设置，就更带感，当然这是后话了。</p><h3 id="很丑，但等着"><a href="#很丑，但等着" class="headerlink" title="很丑，但等着"></a>很丑，但等着</h3><p>效果是完成了，不过九折水瓶。就是基本效果都有了就是了。</p><iframe height="600" width="600" frameborder="no" border="0" src="show.gif"> </iframe>​                                  <p><a href="main.qml">main.qml</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> qt </tag>
            
            <tag> c++ </tag>
            
            <tag> qml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于获取、解析、分析dbus返回值 —— xml的使用</title>
      <link href="/dbus-data-get-3/"/>
      <url>/dbus-data-get-3/</url>
      
        <content type="html"><![CDATA[<a class="theme-btn" href="https://blog.csdn.net/weixin_38627652" title="outline blue larger"><i class="far fa-hand-point-right"></i>去我的csdn博客看看呗</a><a class="theme-btn" href="https://nightcivet.site/dbus-data-get/" title="outline blue larger"><i class="far fa-hand-point-right"></i>关于获取、解析、分析dbus返回值 —— glib库</a><a class="theme-btn" href="https://nightcivet.site/dbus-data-get-2/" title="outline blue larger"><i class="far fa-hand-point-right"></i>关于获取、解析、分析dbus返回值 —— QDBus类</a><hr><p>​                                              </p><h3 id="追求"><a href="#追求" class="headerlink" title="追求"></a>追求</h3><p>偶然在一个别的源码看到一个更方便的写法。</p><p>总体来说就一个xml和一些类型配置就解决了所有的问题，关键是这种方法是真的很方便简洁，如果以后需要调用别的dbus也可以模仿一下。</p><p>先总结一下主要的流程：</p><ol><li><a href="org.freedesktop.login1.Manager.xml">xml</a> 中写好标准的dbus接口写法，感觉是官方给出来的，但又找不到哈哈哈。好吧就算官方找不到自己写也行，就是有点多；</li><li>cmake中可以通过QT5_ADD_DBUS_INTERFACE宏把xml自动生成cpp和h文件，主要提供了总线的方法接口；</li><li>新建cpp和h文件处理一些复合类型数据，合入到生成的总线接口类中；</li></ol><p>​                                           </p><h3 id="生成的接口类"><a href="#生成的接口类" class="headerlink" title="生成的接口类"></a>生成的接口类</h3><p>有了xml后，在CMakeList.txt中加入:</p><pre class=" language-cmake"><code class="language-cmake">QT5_ADD_DBUS_INTERFACE(DBUS_INTERFACE_SRCS    org.freedesktop.login1.Manager.xml    login1_manager)</code></pre><p>命名为DBUS_INTERFACE_SRCS了，在add_executable后面添加此源add_executable(${PROJECT_NAME} “main.cpp” xxx… ${DBUS_INTERFACE_SRCS} )</p><p>在cmake的build目录里，会生成名为login1_manager.cpp和头文件，名字也是自己定的。</p><p>查看生成的login1_manager.h，它生成了一个OrgFreedesktopLogin1ManagerInterface类，继承QDBusAbstractInterface，就是qdbus类相关的操作，而后面的接口类似</p><pre class=" language-c++"><code class="language-c++">...inline QDBusPendingReply<InhibitorList> ListInhibitors()&#123;QList<QVariant> argumentList;return asyncCallWithArgumentList(QStringLiteral("ListInhibitors"), argumentList);&#125;inline QDBusPendingReply<NamedSeatPathList> ListSeats()&#123;QList<QVariant> argumentList;return asyncCallWithArgumentList(QStringLiteral("ListSeats"), argumentList);&#125;inline QDBusPendingReply<SessionInfoList> ListSessions()&#123;QList<QVariant> argumentList;return asyncCallWithArgumentList(QStringLiteral("ListSessions"), argumentList);&#125;inline QDBusPendingReply<UserInfoList> ListUsers()&#123;QList<QVariant> argumentList;return asyncCallWithArgumentList(QStringLiteral("ListUsers"), argumentList);&#125;inline QDBusPendingReply<> LockSession(const QString &in0)&#123;QList<QVariant> argumentList;argumentList << QVariant::fromValue(in0);return asyncCallWithArgumentList(QStringLiteral("LockSession"), argumentList);&#125;...</code></pre><p>全都是自动生成！</p><p>后面可以使用此类直接调用需要的方法了。</p><p>​                                       </p><h3 id="类型处理"><a href="#类型处理" class="headerlink" title="类型处理"></a>类型处理</h3><p>在上一节中有提到，就是元数据声明定义之类的，把它同一放起来就行。</p><p>在CMakeList.txt中添加</p><pre class=" language-cmake"><code class="language-cmake">set_source_files_properties("$&#123;CMAKE_SOURCE_DIR&#125;/org.freedesktop.login1.Manager.xml" PROPERTIES   INCLUDE "LogindDBusTypes.h")</code></pre><p>使它包含这个类型头文件，在这类型头文件里进行元数据声明，流操作定义，元数据注册操作即可。</p><p>感觉也是官方给的，就是找不到官方的地址了，这些看起来格式都一样，改也很容易改</p><p><a href="LogindDBusTypes.cpp">LogindDBusTypes.cpp</a></p><p><a href="LogindDBusTypes.h">LogindDBusTypes.h</a></p><p>由于生成的接口类头文件login1_manager.h是在cmake构建工程目录上面的，所以它会找不到处在源文件目录上的LogindDBusTypes.h，这时只需要拷贝这个头文件过去即可：</p><pre class=" language-cmake"><code class="language-cmake">configure_file("LogindDBusTypes.h" "$&#123;CMAKE_BINARY_DIR&#125;/LogindDBusTypes.h" COPYONLY)</code></pre><p>​                                      </p><h3 id="用起来！"><a href="#用起来！" class="headerlink" title="用起来！"></a>用起来！</h3><p>用就更简单了，直接疯狂调用接口即可：</p><pre class=" language-c++"><code class="language-c++">if (Logind::isAvailable()) &#123;        OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());        auto reply = manager.ListSessions();        reply.waitForFinished();        for (int i = 0; i < reply.value().count(); i++)&#123;            qCritical() << reply.value().at(i).userName;        &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> dbus </tag>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于获取、解析、分析dbus返回值 —— QDBus类</title>
      <link href="/dbus-data-get-2/"/>
      <url>/dbus-data-get-2/</url>
      
        <content type="html"><![CDATA[<a class="theme-btn" href="https://blog.csdn.net/weixin_38627652" title="outline blue larger"><i class="far fa-hand-point-right"></i>去我的csdn博客看看呗</a><a class="theme-btn" href="https://nightcivet.site/dbus-data-get/" title="outline blue larger"><i class="far fa-hand-point-right"></i>关于获取、解析、分析dbus返回值 —— glib库</a><a class="theme-btn" href="https://nightcivet.site/dbus-data-get-3/" title="outline blue larger"><i class="far fa-hand-point-right"></i>关于获取、解析、分析dbus返回值 —— xml的使用</a><hr><p>​                                   </p><h3 id="坐下吧C"><a href="#坐下吧C" class="headerlink" title="坐下吧C"></a>坐下吧C</h3><p>哈哈哈哈哈哈哈哈哈哈，还好有一股淡淡的质疑精神。</p><p>就是作为一个设计好的qdbus类怎么可能解析不了返回值呢哈哈哈额。</p><p>看着这花里胡哨的高级编写语言，还真是牛逼哄哄的。</p><p>​                                      </p><h3 id="看着就很简单明了的步骤"><a href="#看着就很简单明了的步骤" class="headerlink" title="看着就很简单明了的步骤"></a>看着就很简单明了的步骤</h3><p>突然明白，很多东西都有方法和轮子了，只不过是自己没找到而已。</p><p>现在很需要解析systemd中的login1总线上listsessions中返回的数据，获取目前系统上已登录用户的sessionid、name等等，ok其实也就几个关键的步骤：</p><p>​                                                   </p><h4 id="新建QDBusInterface"><a href="#新建QDBusInterface" class="headerlink" title="新建QDBusInterface"></a>新建QDBusInterface</h4><p>这个就比较朴实无华，常规操作即可，按照dbus位置填入即可：</p><pre class=" language-c++"><code class="language-c++">#define SYSTEMD_SERVICE         "org.freedesktop.login1"#define SYSTEMD_PATH            "/org/freedesktop/login1"#define SYSTEMD_INTERFACE       "org.freedesktop.login1.Manager"QDBusInterface interface( SYSTEMD_SERVICE,                              SYSTEMD_PATH,                              SYSTEMD_INTERFACE,                              QDBusConnection::systemBus() );</code></pre><p>​                                        </p><h4 id="异步调用、QDBusPendingReply"><a href="#异步调用、QDBusPendingReply" class="headerlink" title="异步调用、QDBusPendingReply"></a>异步调用、QDBusPendingReply</h4><p>虽说同步调用总线method似乎也没什么大问题，但万一卡住了呢？</p><p>并且异步调用也封装的非常好，也不用操作什么，使用QDBusPendingReply类接受返回值，可以解析复合类型的类型结构，这就是重中之重。</p><p>异步调用的接口为asyncCall，这个是默认不传参的，还有一个asyncCallWithArgumentList是带着QList<QVariant>参数的接口，用哪个都行，不传就留空呗~</QVariant></p><p>配合上总线method名称，就是这样子：</p><pre class=" language-c++"><code class="language-c++">QDBusPendingReply<SessionInfoList> reply = interface.asyncCall(QStringLiteral("ListSessions"));reply.waitForFinished();</code></pre><p>而至于这个SessionInfoList，就是要自定的复合数据结构类型；</p><p>从上一次查资料<a href="https://www.freedesktop.org/wiki/Software/systemd/logind/">logind</a>中看到，listsessions返回类型为 <strong>a(susso)</strong> 这个东西，也就是一个复合数据列表；</p><p>ok官网介绍如下：</p><blockquote><p><strong>ListSessions()</strong> returns an array with all current sessions. The structures in the array consist of the following fields: session id, user id, user name, seat id, session object path. If a session does not have a seat attached the seat id field will be an empty string.</p></blockquote><p>那便根据名字定义这个结构体如下：</p><pre class=" language-c++"><code class="language-c++">struct SessionInfo&#123;    QString sessionId;    uint userId;    QString userName;    QString seatId;    QDBusObjectPath sessionPath;&#125;;</code></pre><p>再把它弄成一个列表：</p><pre class=" language-c++"><code class="language-c++">typedef QList<SessionInfo> SessionInfoList;</code></pre><p>正常来说这时基本都完成了，可编译报错，关于一些数据元错误的东西；</p><p>也是上网查主要是注意3个地方：</p><h5 id="元数据声明"><a href="#元数据声明" class="headerlink" title="元数据声明"></a>元数据声明</h5><p>由于自定义类型数据在传入接口后会进行一些QVariant传递，还是得把自定义类型声明为qt元数据：</p><pre class=" language-c++"><code class="language-c++">Q_DECLARE_METATYPE(SessionInfoList);Q_DECLARE_METATYPE(SessionInfo);</code></pre><h5 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h5><p>同理接口会对自定义类型进行流操作，操作符&lt;&lt;和操作符&gt;&gt;流函数必须始终生成自定义数据类型相同数量的条目，得实现一下：</p><pre class=" language-c++"><code class="language-c++">inline QDBusArgument &operator<<(QDBusArgument &argument, const SessionInfo& sessionInfo)&#123;    argument.beginStructure();    argument << sessionInfo.sessionId;    argument << sessionInfo.userId;    argument << sessionInfo.userName;    argument << sessionInfo.seatId;    argument << sessionInfo.sessionPath;    argument.endStructure();    return argument;&#125;inline const QDBusArgument &operator>>(const QDBusArgument &argument, SessionInfo &sessionInfo)&#123;    argument.beginStructure();    argument >> sessionInfo.sessionId;    argument >> sessionInfo.userId;    argument >> sessionInfo.userName;    argument >> sessionInfo.seatId;    argument >> sessionInfo.sessionPath;    argument.endStructure();    return argument;&#125;</code></pre><h5 id="元数据注册"><a href="#元数据注册" class="headerlink" title="元数据注册"></a>元数据注册</h5><ol><li><p>qRegisterMetaType&lt;SessionInfo&gt;(“SessionInfo”);qRegisterMetaType&lt;SessionInfoList&gt;(“SessionInfoList”);</p><p>在slot\signal中如果传递了此类型参数，需先注册。虽说用不到，但先注册也是好的。</p></li><li><p>qDBusRegisterMetaType&lt;SessionInfo&gt;();qDBusRegisterMetaType&lt;SessionInfoList&gt;();</p><p>在qdbus中想用扩展自定义类型，就得先注册。</p></li></ol><h3 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h3><p>在cmakelist中加上关于dbus的库，便可编译看看想要的数据；</p><pre class=" language-cmake"><code class="language-cmake">find_package(Qt5 $&#123;QT_MINIMUM_VERSION&#125; CONFIG REQUIRED DBus)target_link_libraries($&#123;PROJECT_NAME&#125; Qt5::Core Qt5::DBus)</code></pre><p>比如想看看sessionid，就可直接reply：</p><pre class=" language-c++"><code class="language-c++">for (int i = 0; i < reply.value().count(); i++)&#123;        qCritical() << reply.value().at(i).sessionId;    &#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> dbus </tag>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于获取、解析、分析dbus返回值 —— glib库</title>
      <link href="/dbus-data-get/"/>
      <url>/dbus-data-get/</url>
      
        <content type="html"><![CDATA[<a class="theme-btn" href="https://blog.csdn.net/weixin_38627652" title="outline blue larger"><i class="far fa-hand-point-right"></i>去我的csdn博客看看呗</a><a class="theme-btn" href="https://nightcivet.site/dbus-data-get-2/" title="outline blue larger"><i class="far fa-hand-point-right"></i>关于获取、解析、分析dbus返回值 —— QDBus类</a><a class="theme-btn" href="https://nightcivet.site/dbus-data-get-3/" title="outline blue larger"><i class="far fa-hand-point-right"></i>关于获取、解析、分析dbus返回值 —— xml的使用</a><hr><p>​                                              </p><h3 id="看到用不到"><a href="#看到用不到" class="headerlink" title="看到用不到"></a>看到用不到</h3><p>是这样，在qdbusviewer中可以直接调用一些总线的方法，也看到自己想要的返回值。</p><p><img src="/dbus-data-get/qdusviewer.png"></p><p>正常来说，都会用QDBusMessage result = interface.call()来获取调用了这个方法的返回值，interface是QDBusInterface类，定义了总线的位置。</p><p>但那QDBusMessage是一连串的东西，我需要拆分这一连串的东西得到里面的独立的参数，比如里面的字符串，整形等等。</p><p>可QDBusMessage不是简单的字符串，要操作起来才行。 </p><p>​                                               </p><h4 id="尝试一步步解析"><a href="#尝试一步步解析" class="headerlink" title="尝试一步步解析"></a>尝试一步步解析</h4><p>这边是参考了一篇文章<a href="http://www.voidcn.com/article/p-nsytgtkm-btm.html">c++ 如何在Qt DBus调用中从QDBusMessage中提取返回的数据？</a>，感觉就是在套娃，做的是解套娃，跟着做着做着做到倒数第二步，用QDBusArgument截取的返回值类型打印出来是unkown，心态不就崩了嘛？</p><p>​                                 </p><h4 id="从返回信息入手"><a href="#从返回信息入手" class="headerlink" title="从返回信息入手"></a>从返回信息入手</h4><p>就仔细瞧瞧返回值：</p><p>[Argument: a(susso) {[Argument: (susso) “xx”, xx, “xx”, “xx”, [ObjectPath: xxx], [Argument: (susso) “xx”, xx, “xx”, “xx”, [ObjectPath: xxx]}]</p><p>那时就感觉有点妙，s string，u unsigned int， o object，跟后边的参数一模一样的类型，突然感觉到了希望。</p><p>所以往这方面去找资料，找到了一个很相似的：<a href="https://ask.csdn.net/questions/385340">GDBUS g_variant_get多个字符串的GVariant*类型 Tuples解析</a>。</p><p>然后继续失败，感觉是那个a(susso)的a的问题，毕竟别人没有a。</p><p>继续查，发现真的是a的问题，a代表array，也就是这里是一个数组数列，反正要迭代再解析。</p><p>​                                   </p><h3 id="翻滚吧，C！"><a href="#翻滚吧，C！" class="headerlink" title="翻滚吧，C！"></a>翻滚吧，C！</h3><p>竟然想不到是C搞定了，在上面的基础上，加一层迭代就能完成目标，再加上网上查到的一些glib dbus函数的调用，结果就能出来了！</p><pre class=" language-c++"><code class="language-c++">#include <glib.h>#include <gio/gio.h>#include <QDebug>int main()&#123;    GDBusProxy *login_proxy = NULL;    GVariant *listsession_var = NULL;    GError *error = NULL;    login_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM,                    G_DBUS_PROXY_FLAGS_NONE,                    NULL,                    "org.freedesktop.login1",                    "/org/freedesktop/login1",                    "org.freedesktop.login1.Manager",                    NULL,                    &error);    if (error != NULL) &#123;        g_error_free(error);        return 1;    &#125;    error = NULL;    listsession_var = g_dbus_proxy_call_sync (login_proxy,                        "ListSessions",                        NULL,                        G_DBUS_CALL_FLAGS_NONE,                        -1,                        NULL,                        &error);    if (listsession_var == NULL) &#123;        g_object_unref(login_proxy);        return 1;    &#125;    g_object_unref(login_proxy);    GVariantIter *iter;    g_variant_get(listsession_var, "(a(susso))", &iter);    gchar *sessionId, *userName, *seatId;    guint32 userId;    GObject *objectPath;    while (g_variant_iter_loop (iter, "(susso)", &sessionId, &userId, &userName, &seatId, &objectPath))    &#123;        qCritical() << sessionId << userName << seatId << userId;    &#125;    g_variant_iter_free (iter);    g_variant_unref(listsession_var);    return 0;&#125;</code></pre><p>看着这满满的C风格，真是意犹未尽。</p><p>这边使用cmake管理，链接库要加上glib2的库target_link_libraries(${PROJECT_NAME} Qt5::Core Qt5::Widgets gio-2.0 gobject-2.0 glib-2.0)</p><p>逻辑也是比较简单，g_dbus_proxy_call_sync得到最外圈的数据，g_variant_get解了一圈a，得到一个迭代指针iter，g_variant_iter_loop得到iter里面的每一项内容。</p><p>打印出来结果，还是很满意的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> dbus </tag>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qstyle 一步一个jio印（4）—— 整理框架 阅读理解</title>
      <link href="/qstyle-4/"/>
      <url>/qstyle-4/</url>
      
        <content type="html"><![CDATA[<a class="theme-btn" href="https://blog.csdn.net/weixin_38627652" title="outline blue larger"><i class="far fa-hand-point-right"></i>去我的csdn博客看看呗</a><a class="theme-btn" href="https://nightcivet.site/qstyle-1/" title="outline blue larger"><i class="far fa-hand-point-right"></i>qstyle 一步一个jio印（1）——工程目录建设 cmakelist规则</a><a class="theme-btn" href="https://nightcivet.site/qstyle-2/" title="outline blue larger"><i class="far fa-hand-point-right"></i>qstyle 一步一个jio印（2）——子元素编辑 样式效果初现</a><a class="theme-btn" href="https://nightcivet.site/qstyle-3/" title="outline blue larger"><i class="far fa-hand-point-right"></i>qstyle 一步一个jio印（3）——添加动画 水波纹效果</a><hr><h3 id="最后了！"><a href="#最后了！" class="headerlink" title="最后了！"></a>最后了！</h3><p>是这样，大佬们查看了框架，然后自己简化了一套出来，融合进了代码。</p><p>而我，跟随这这套框架继续拧螺丝，开始压根不用管框架做了什么，直接调用即可。</p><p>现在慢慢理解框架，看看框架处理了什么东西吧。</p><p>当然，在运行完整的demo和运行自己随便添加效果的demo相比，差距还是很大的。</p><p>那么，其实可以理解成有框架和没框架的差距，就能加深理解框架究竟在干嘛。</p><p>​                                     </p><h3 id="暴露问题"><a href="#暴露问题" class="headerlink" title="暴露问题"></a>暴露问题</h3><p>从效果上看，没了框架，动画资源的管理很不方便。就在上一节中，我们只有一个动画资源，绑定的只有一个target即一个button，那时设置是每次点击都把上一个资源给释放掉，重新分配给当前点击的控件。这样问题就很大了呀：</p><ol><li>当点完一个按钮立刻点另一个按钮，上一个按钮的动画还没结束就delete掉了？</li><li>当连续点击一个按钮，资源也是释放得太快甚至都没开始？</li><li>绘制元素函数是不区分button的统一绘制入口，分不清楚当前播放动画的究竟是哪一个button？</li></ol><iframe height="253" width="384" frameborder="no" border="0" src="animation-wrong.gif"> </iframe>​                                   <p>从图中看出问题所在，先直面效果中出现的问题，在代码中解释如下：</p><ol><li>点击一个按钮后，移动鼠标到另一个按钮2，显然2虽然没点击但动画资源有数据，由于数据没有绑定按钮2，所以按钮2只有一刻的圆；</li><li>点击按钮1速度再点按钮2，按钮1的波纹立刻没了；</li><li>连续点击按钮1，效果很差懒得描述；</li></ol><p>​                                                       </p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>框架很复杂，但主要包含两个方面：</p><ol><li>让控件和动画资源绑定，建立起联系，让每个控件都有独立的动画资源；</li><li>允许每个控件拥有多个动画资源，同时需要管理多个动画资源；</li></ol><p>这样，当我们连续点击同一个按钮，产生了多个按钮1的动画资源，动画1在跑同时动画2也在跑，互不影响。或者连续切换按钮点，按钮1的动画和按钮2的动画独立的跑也互不影响了。</p><p>​                                                </p><h3 id="开始吧阅读理解"><a href="#开始吧阅读理解" class="headerlink" title="开始吧阅读理解"></a>开始吧阅读理解</h3><p>代码实在太多太杂。只能按照步骤一个一个来，去除一些不太关键的资源释放的步骤吧。</p><p>​                                                          </p><h4 id="引擎管理"><a href="#引擎管理" class="headerlink" title="引擎管理"></a>引擎管理</h4><p>这边我理解是数据的触发，就像一个引擎：</p><pre class=" language-c++"><code class="language-c++">Animations::Animations( QObject* parent ): QObject( parent )&#123;    registerEngine( _widgetStateEngine = new WidgetStateEngine( this ) );&#125;Animations::~Animations()&#123;&#125;WidgetStateEngine& Animations::widgetStateEngine( void ) const&#123;    return *_widgetStateEngine;&#125;void Animations::registerWidget( QWidget* widget ) const&#123;    if( !widget ) return;    if( qobject_cast<QPushButton *>(widget) ) &#123;        _widgetStateEngine->registerWidget( widget);    &#125;    return;&#125;</code></pre><p>这里就是新建了一个引擎，让引擎注册了button控件，接下来就是引擎在干嘛？</p><p>​                                    </p><h4 id="绑定控件"><a href="#绑定控件" class="headerlink" title="绑定控件"></a>绑定控件</h4><pre class=" language-c++"><code class="language-c++">bool WidgetStateEngine::registerWidget(QWidget* widget)&#123;    if( !widget ) return false;    if(!m_data.contains( widget ) ) &#123; m_data.insert( widget, new WidgetStateData( this, widget)); &#125;    connect( widget, SIGNAL(destroyed(QObject*)), this, SLOT(unregisterWidget(QObject*)), Qt::UniqueConnection );    return true;&#125;</code></pre><p>m_data是一个封装了一些函数的qmap数据结构，以输入的widget为键，数据类为键值。</p><p>那么，这个数据类WidgetStateData又在干嘛呢？</p><p>​                              </p><h4 id="设置触发条件，设置动画参数"><a href="#设置触发条件，设置动画参数" class="headerlink" title="设置触发条件，设置动画参数"></a>设置触发条件，设置动画参数</h4><pre class=" language-c++"><code class="language-c++">WidgetStateData::WidgetStateData(QObject* parent, QWidget* target):    GenericData(parent, target)&#123;    target->installEventFilter(this);&#125;WidgetStateData::~WidgetStateData()&#123;&#125;bool WidgetStateData::eventFilter(QObject *object, QEvent *event)&#123;    if(target() != object)        return GenericData::eventFilter( object, event );    if (object->inherits("QPushButton"))&#123;        switch( event->type() )        &#123;        case QEvent::MouseButtonPress:            startRipple(static_cast<QMouseEvent *>(event), target());            break;        default: break;        &#125;        return GenericData::eventFilter( object, event );    &#125;&#125;void WidgetStateData::startRipple(QMouseEvent *event, QWidget *target)&#123;    QPoint pos = target->rect().center();    qreal radiusEndValue = static_cast<qreal>(target->width());    MaterialRipple *ripple = new MaterialRipple(pos, target);    ripple->setOpacityStartValue(0.35);    ripple->setOpacityEndValue(0);    ripple->setRadiusStartValue(0);    ripple->setRadiusEndValue(radiusEndValue);    ripple->radiusAnimation()->setDuration(1600);    ripple->opacityAnimation()->setDuration(1300);    addRipple(ripple);&#125;</code></pre><p>这里为注册的控件重载了事件过滤，在这里设置触发，至于这个动画类MaterialRipple上一节已经理解过了。</p><p>而这个数据类的父类GenericData就是曾经提到的管理，它的作用主要是管理多个动画资源：</p><pre class=" language-c++"><code class="language-c++">void GenericData::addRipple(MaterialRipple *ripple)&#123;    m_animations.push_back(ripple);    ripple->start();    connect(ripple, SIGNAL(finished()), this, SLOT(removeRipple()));    connect(this, SIGNAL(destroyed(QObject*)), ripple, SLOT(stop()));    connect(this, SIGNAL(destroyed(QObject*)), ripple, SLOT(deleteLater()));&#125;void GenericData::removeRipple()&#123;    MaterialRipple *ripple = qobject_cast<MaterialRipple *>(sender());    if(m_animations.removeOne(ripple))&#123;        ripple->deleteLater();    &#125;&#125;void GenericData::removeAllRipple()&#123;    foreach(MaterialRipple *ripple, m_animations)&#123;        m_animations.removeOne(ripple);        ripple->deleteLater();    &#125;&#125;QWidget * GenericData::target() const&#123;    return m_target;&#125;QList<RippleData> GenericData::ripples()&#123;    QList<RippleData> result;    qCritical() << m_animations.count();    foreach(MaterialRipple *ripple, m_animations)&#123;        RippleData data;        data.radius = ripple->radius();        data.opacity = ripple->opacity();        result.append(data);    &#125;    return result;&#125;</code></pre><p>m_animations保存着多个动画资源，同时也可控制删除，数据可通过ripples访问；</p><p>​                            </p><h3 id="调用与回顾"><a href="#调用与回顾" class="headerlink" title="调用与回顾"></a>调用与回顾</h3><p>在mystyle中新建animation类，在polish(QWidget *widget)中注册widget：_animation-&gt;registerWidget(widget);</p><p>在绘制button元素的最后加上数据即可：</p><pre class=" language-c++"><code class="language-c++">QList<RippleData> rippleDatas = _animation->widgetStateEngine().ripples(widget);if (enabled)&#123;    foreach (RippleData data, rippleDatas) &#123;        QPointF center = rect.center();        painter->setOpacity(data.opacity);        QBrush brush;        brush.setColor(palette.color(QPalette::Highlight));        brush.setStyle(Qt::SolidPattern);        painter->setBrush(brush);        painter->drawEllipse(center, data.radius, data.radius);    &#125;&#125;</code></pre><p>回顾一下，在这个注册的时候，所有按钮该绑定的已经绑定好了，触发条件该设置的已经设置好了。</p><p>在调用_animation-&gt;widgetStateEngine().ripples(widget)的时候，就是根据widget为键在qmap数据结构中寻找键值，键值是数据类，它的ripple()即是GenericData类保存的数据了。</p><p>这时抛开代码，简化过程：</p><h4 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h4><p>建立引擎 -&gt; 引擎建立qmap数据结构，键为widget键值为WidgetStateData类 -&gt; WidgetStateData类设置鼠标点击事件要产生动画类MaterialRipple -&gt; MaterialRipple类生成一堆数据 -&gt; MaterialRipple类的数据以及自己在GenericData管理。</p><h4 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h4><p>点击按钮 -&gt; 去引擎查找当前widget为键的键值 -&gt; 访问到对应WidgetStateData类 -&gt; 访问到WidgetStateData类的父类GenericData类保存的数据</p><p>​                                   </p><h3 id="落幕"><a href="#落幕" class="headerlink" title="落幕"></a>落幕</h3><p>最终的效果，显示出来的就应该是丝滑的感觉。</p><iframe height="253" width="384" frameborder="no" border="0" src="animation-right.gif"> </iframe>]]></content>
      
      
      
        <tags>
            
            <tag> qt </tag>
            
            <tag> linux </tag>
            
            <tag> qstyle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qstyle 一步一个jio印（3）—— 添加动画 水波纹效果</title>
      <link href="/qstyle-3/"/>
      <url>/qstyle-3/</url>
      
        <content type="html"><![CDATA[<a class="theme-btn" href="https://blog.csdn.net/weixin_38627652" title="outline blue larger"><i class="far fa-hand-point-right"></i>去我的csdn博客看看呗</a><a class="theme-btn" href="https://nightcivet.site/qstyle-1/" title="outline blue larger"><i class="far fa-hand-point-right"></i>qstyle 一步一个jio印（1）——工程目录建设 cmakelist规则</a><a class="theme-btn" href="https://nightcivet.site/qstyle-2/" title="outline blue larger"><i class="far fa-hand-point-right"></i>qstyle 一步一个jio印（2）——子元素编辑 样式效果初现</a><a class="theme-btn" href="https://nightcivet.site/qstyle-4/" title="outline blue larger"><i class="far fa-hand-point-right"></i>qstyle 一步一个jio印（4）—— 整理框架 阅读理解</a><hr><h3 id="添砖加瓦"><a href="#添砖加瓦" class="headerlink" title="添砖加瓦"></a>添砖加瓦</h3><p>细想已经实现了一个控件的各种状态（聚焦、鼠标悬浮、点击、使能、失能等）中的样式绘制和控制，已经基本上完成了定制的实现了，剩下就是能够为这个控件加点什么，比如说，加个水波纹动画啥的。</p><p>看看源码中的动画实现，那才叫真正的框架啊啊啊，真正的框架是看不懂的额。</p><p>所以说，只能尽量理解源码中的方法，加上查阅一下资料，再一行一行慢慢验证实验看下了。</p><p>这次我们就不追求别人的框架了，先用最浅显的代码弄好效果再说吧qaq。</p><p>​                                       </p><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>通过查看相关资料，说白了qt动画最必要的是在一段短时间内生成一堆连续的间隔较小的数，如透明度，当透明度为1时就是不透明，为0就是全透明，在0 - 1之间生成间隔不大的很多个数，再应用在控件上，就有了渐渐不透明或者渐渐透明的动画效果~</p><p>这次的目标，水波纹包含着两个数，一个是画水波纹不断扩大的圆型，另一个就是让水波纹逐渐消失透明度。</p><p>在那些绘制函数里，有控件的画笔，直接用这只笔基于这个控件再画一层东西即可。</p><p>而数据产生，qt有类QParallelAnimationGroup、QPropertyAnimation帮我们解决，QPropertyAnimation用法通常为绑定某控件的属性，设置开始数值和结束数和时间，产生一堆两数值间的一堆数据应用在这个控件的属性上，对这个属性进行改动。</p><p>而目标是再画一层水波纹，不方便直接修改控件的属性，所以新建一个数据类保存这些数据，让QPropertyAnimation绑定的是这个类的属性即可。</p><p>​                                                           </p><h3 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h3><p>学习下源码，在代码目录下新建一个animation的类，里面存放所有关于动画的实现文件。</p><p>我们目标很明确，随便弄个类，里面有两个变量方便绑定即可。</p><p>​                                               </p><h4 id="新建类绑定变量"><a href="#新建类绑定变量" class="headerlink" title="新建类绑定变量"></a>新建类绑定变量</h4><p>新建一个类，继承QParallelAnimationGroup，类里面加入方便绑属性</p><pre class=" language-c++"><code class="language-c++">Q_PROPERTY(qreal radius WRITE setRadius READ radius)Q_PROPERTY(qreal opacity WRITE setOpacity READ opacity)</code></pre><p>新建属性：</p><pre class=" language-c++"><code class="language-c++">QPropertyAnimation *const m_radiusAnimation;QPropertyAnimation *const m_opacityAnimation;QWidget            *const m_target;qreal                     m_radius;qreal                     m_opacity;</code></pre><p>其中QPropertyAnimation就是能产生一堆连续数据的类了，target用来绑定控件。</p><p>绑定的代码如下：</p><pre class=" language-c++"><code class="language-c++">QPropertyAnimation *m_opacityAnimation = new QPropertyAnimation;m_opacityAnimation->setTargetObject(this);m_opacityAnimation->setPropertyName(“opacity”);m_opacityAnimation->setEasingCurve(easing);m_opacityAnimation->setDuration(duration);addAnimation(animation);</code></pre><p>首先把setTargetObject，目标为这个类，setPropertyName也就绑定了这个类的opacity属性，也是刚刚新建的Q_PROPERTY里面。再添加开始数值，结束数值，时间，就可以等待它的start了：</p><pre class=" language-c++"><code class="language-c++">m_opacityAnimation->setStartValue(1);m_opacityAnimation->setEndValue(0);m_opacityAnimation->setDuration(duration);</code></pre><p>由于是改动了Q_PROPERTY里的数值，自定义一下设置这个数值的函数：</p><pre class=" language-c++"><code class="language-c++">void MaterialRipple::setOpacity(qreal opacity)&#123;    if (qFuzzyCompare(m_opacity,opacity)) &#123;        return;    &#125;    m_opacity = opacity;    m_target->update();&#125;</code></pre><p>这个target就是我们待绘制的button，调用它的update时它会进行一次绘制，相当于通知了这个button要进行绘制了，我的opacity更新了。</p><p>radius也是一模一样的，改一下数值即可；</p><p>​                                             </p><h4 id="button触发"><a href="#button触发" class="headerlink" title="button触发"></a>button触发</h4><p>就是点击的时候触发了这个水波纹动画，在mystyle中是removeEventFilter了button和重新installEventFilter了一遍的，所以写eventfilter时加入：</p><pre class=" language-c++"><code class="language-c++">&#123;% btn 'https://nightcivet.site/qstyle-3/',qstyle 一步一个jio印（3）—— 添加动画 水波纹效果,far fa-hand-point-right,outline blue larger %&#125;bool MyStyle::eventFilter(QObject *object, QEvent *event)&#123;    if (QPushButton *button = qobject_cast<QPushButton *>(object)) &#123;        switch (event->type()) &#123;            case QEvent::MouseButtonPress:            &#123;                xxx...            &#125;        &#125;    &#125;    return QCommonStyle::eventFilter(object, event);&#125;</code></pre><p>这里的内容xxx即可上刚刚新建的类，同时可以把button参数传进去了！调用动画类的start()，就开始了数据产生！</p><p>​                                   </p><h3 id="画！"><a href="#画！" class="headerlink" title="画！"></a>画！</h3><p>直接在drawPanelButtonCommandPrimitive函数最后加入：</p><pre class=" language-c++"><code class="language-c++">if (ripple && enabled)&#123;        const QPointF center = ripple->center();        painter->setOpacity(ripple->opacity());        QBrush brush;        brush.setColor(palette.color(QPalette::Highlight));        brush.setStyle(Qt::SolidPattern);        painter->setBrush(brush);        painter->drawEllipse(center, ripple->radius(), ripple->radius());&#125;</code></pre><p>这个ripple便是新建的数据类，表示波纹嘛，和之前说的一样，设置透明度，画圆即可。</p><p>​                                             </p><h3 id="效果！"><a href="#效果！" class="headerlink" title="效果！"></a>效果！</h3><p>故意调慢了一点时间，颜色也随便上了，就是这样的效果。</p><p>bug还是挺多的，比如连续点击时会出问题，两个button快速切换点击也是，其实就是没有处理动画还没完成的情况，包括控件多的时候的情况；</p><p>就是缺乏对这种数据的管理，所以源码框架就是做这些事情，管理控件与动画的绑定，管理动画开始结束的控制。</p><iframe height="253" width="384" frameborder="no" border="0" src="animation.gif"> </iframe><p>​                                           </p>]]></content>
      
      
      
        <tags>
            
            <tag> qt </tag>
            
            <tag> linux </tag>
            
            <tag> qstyle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qstyle 一步一个jio印（2）——子元素编辑 样式效果初现</title>
      <link href="/qstyle-2/"/>
      <url>/qstyle-2/</url>
      
        <content type="html"><![CDATA[<a class="theme-btn" href="https://blog.csdn.net/weixin_38627652" title="outline blue larger"><i class="far fa-hand-point-right"></i>去我的csdn博客看看呗</a><a class="theme-btn" href="https://nightcivet.site/qstyle-1/" title="outline blue larger"><i class="far fa-hand-point-right"></i>qstyle 一步一个jio印（1）——工程目录建设 cmakelist规则</a><a class="theme-btn" href="https://nightcivet.site/qstyle-3/" title="outline blue larger"><i class="far fa-hand-point-right"></i>qstyle 一步一个jio印（3）—— 添加动画 水波纹效果</a><a class="theme-btn" href="https://nightcivet.site/qstyle-4/" title="outline blue larger"><i class="far fa-hand-point-right"></i>qstyle 一步一个jio印（4）—— 整理框架 阅读理解</a><hr><h4 id="接着干！"><a href="#接着干！" class="headerlink" title="接着干！"></a>接着干！</h4><p>以弄好一个pushbutton为目标，使劲的去看代码并抄一抄流程，适当进行改动能深入理解该地方的用处！</p><p>​                             </p><h4 id="还是先整合好框架然后留空"><a href="#还是先整合好框架然后留空" class="headerlink" title="还是先整合好框架然后留空"></a>还是先整合好框架然后留空</h4><p>通过查阅资料观察流程，得到基本原理。每个控件有若干个子元素构成，而插件通过修改编辑这些子元素打到修改控件外观的效果。</p><p>所以步骤是一样的，代码和网上说的也差不多。基本都是编写好父类的虚函数就行了</p><p>ok我们的主要编辑文件mystyle这个类，开始对它动手动脚。</p><p>​                                                      </p><h4 id="虚函数polish"><a href="#虚函数polish" class="headerlink" title="虚函数polish()"></a>虚函数polish()</h4><p>有三个：</p><ol><li>virtual void polish(QWidget *widget);</li><li>virtual void polish(QPalette &amp;palette);</li><li>virtual void unpolish(QWidget *widget);</li></ol><p>第一个设置一下悬浮，重载一下事件过滤（虽然也没写新的），再调用一下父类：</p><pre class=" language-c++"><code class="language-c++">void MyStyle::polish(QWidget *widget)&#123;    if (!widget)        return;    if (qobject_cast<QPushButton *>(widget))        widget->setAttribute(Qt::WA_Hover);    if (!widget->parent() || !qobject_cast<QWidget *>(widget->parent()) || qobject_cast<QDialog *>(widget) || qobject_cast<QMainWindow *>(widget)) &#123;        addEventFilter(widget);    &#125;    // base class polishing    QCommonStyle::polish(widget);&#125;</code></pre><p>第二个看名字就知道是设置调色版，先随意吧，太长了，大概就那些玩意儿，直接搬过来就是：</p><pre class=" language-c++"><code class="language-c++">void MyStyle::polish(QPalette &palette)&#123;    // Colors defined in GTK adwaita style in _colors.scss    QColor base_color = QColor("#2c9dfc");    QColor text_color = QColor("black");    QColor bg_color = QColor("#f6f5f4");    QColor fg_color = QColor("#2e3436");    QColor selected_bg_color = QColor("#3584e4");    QColor selected_fg_color = QColor("white");    QColor osd_text_color = QColor("white");    QColor osd_bg_color = QColor("black");    QColor shadow = _helper->transparentize(bg_color, 0.9);    QColor backdrop_fg_color = _helper->mix(fg_color, bg_color);    QColor backdrop_base_color = _helper->darken(base_color, 0.01);    QColor backdrop_selected_fg_color = backdrop_base_color;    // This is the color we use as initial color for the gradient in normal state    // Defined in _drawing.scss button(normal)    QColor button_base_color = _helper->darken(QColor("#ffffff"), 0.04);    QColor link_color = _helper->darken(selected_bg_color, 0.1);    QColor link_visited_color = _helper->darken(selected_bg_color, 0.2);    palette.setColor(QPalette::All,      QPalette::Window,          bg_color);    palette.setColor(QPalette::All,      QPalette::WindowText,      fg_color);    palette.setColor(QPalette::All,      QPalette::Base,            base_color);    palette.setColor(QPalette::All,      QPalette::AlternateBase,   base_color);    ...    ...    ...&#125;</code></pre><p>第三个析构，也是直接回归父类就行：</p><pre class=" language-c++"><code class="language-c++">void MyStyle::unpolish(QWidget *widget)&#123;    QCommonStyle::unpolish(widget);&#125;</code></pre><p>​                                                       </p><h4 id="pixelMetric、subElementRect、styleHint、subControlRect、sizeFromContents、hitTestComplexControl"><a href="#pixelMetric、subElementRect、styleHint、subControlRect、sizeFromContents、hitTestComplexControl" class="headerlink" title="pixelMetric、subElementRect、styleHint、subControlRect、sizeFromContents、hitTestComplexControl"></a>pixelMetric、subElementRect、styleHint、subControlRect、sizeFromContents、hitTestComplexControl</h4><p>这几个虚函数都分别微调一些控件子元素的外观矩形大小，这些没有太大的改动，也先直接跳过返回父类即可：</p><pre class=" language-c++"><code class="language-c++">int MyStyle::pixelMetric(PixelMetric metric, const QStyleOption *option, const QWidget *widget) const&#123;    return QCommonStyle::pixelMetric(metric, option, widget);&#125;QRect MyStyle::subElementRect(SubElement element, const QStyleOption *option, const QWidget *widget) const&#123;    return QCommonStyle::subElementRect(element, option, widget);&#125;int MyStyle::styleHint(StyleHint hint, const QStyleOption *option, const QWidget *widget, QStyleHintReturn *returnData) const&#123;    return QCommonStyle::styleHint(hint, option, widget, returnData);&#125;QRect MyStyle::subControlRect(ComplexControl element, const QStyleOptionComplex *option, SubControl subControl, const QWidget *widget) const&#123;    return QCommonStyle::subControlRect(element, option, subControl, widget);&#125;QSize MyStyle::sizeFromContents(ContentsType element, const QStyleOption *option, const QSize &size, const QWidget *widget) const&#123;    return QCommonStyle::sizeFromContents(element, option, size, widget);&#125;QStyle::SubControl MyStyle::hitTestComplexControl(ComplexControl control, const QStyleOptionComplex *option, const QPoint &point, const QWidget *widget) const&#123;    return QCommonStyle::hitTestComplexControl(control, option, point, widget);&#125;</code></pre><p>​                                                          </p><h4 id="drawPrimitive"><a href="#drawPrimitive" class="headerlink" title="drawPrimitive"></a>drawPrimitive</h4><p>绘制PE子元素，其实暂时也不知道怎么查资料可以得到各个控件的子元素有什么，笨拙的通过打印看按钮有什么子元素可太秀了，好的通过打印看出按钮有两个PE子元素：PE_PanelButtonCommand、PE_FrameFocusRect。子元素可在官方文档中查看具体代表是什么，比如第一个官方的描述是“Button used to initiate an action”，第二个其实不用看文档也偶尔猜到是绘制聚焦时的矩形样式；</p><p>分别列出来：</p><pre class=" language-c++"><code class="language-c++">void MyStyle::drawPrimitive(PrimitiveElement element, const QStyleOption *option, QPainter *painter, const QWidget *widget) const&#123;    StylePrimitive fcn(nullptr);    switch (element) &#123;    case PE_PanelButtonCommand:        fcn = &MyStyle::drawPanelButtonCommandPrimitive;        break;    case PE_FrameFocusRect:        fcn = &MyStyle::drawFrameFocusRectPrimitive;        break;    default:        break;    &#125;    painter->save();    // call function if implemented    if (!(fcn && (this->*fcn)(option, painter, widget))) &#123;        QCommonStyle::drawPrimitive(element, option, painter, widget);    &#125;    painter->restore();&#125;</code></pre><p>其中第一句这个算是泛型指针？写着方便，也是高级写法，所指的函数参数都一样，定义是这样的：</p><pre class=" language-c++"><code class="language-c++">using StylePrimitive = bool(MyStyle::*)(const QStyleOption *option, QPainter *painter, const QWidget *widget) const;</code></pre><p>具体绘画函数draw…先留空，这个是真的画画的时候了。</p><p>​                                                                     </p><h4 id="drawComplexControl、drawItemText"><a href="#drawComplexControl、drawItemText" class="headerlink" title="drawComplexControl、drawItemText"></a>drawComplexControl、drawItemText</h4><p>前面这个定制CC子元素，看了下button没有CC子元素，也没有特殊的itemtext需求，也是直接返回父类：</p><pre class=" language-c++"><code class="language-c++">void MyStyle::drawComplexControl(ComplexControl element, const QStyleOptionComplex *option, QPainter *painter, const QWidget *widget) const&#123;    QCommonStyle::drawComplexControl(element, option, painter, widget);&#125;void MyStyle::drawItemText(QPainter *painter, const QRect &rect, int flags, const QPalette &palette, bool enabled,const QString &text, QPalette::ColorRole textRole) const&#123;    return QCommonStyle::drawItemText(painter, rect, flags, palette, enabled, text, textRole);&#125;</code></pre><p>​                                                                  </p><h4 id="drawControl"><a href="#drawControl" class="headerlink" title="drawControl"></a>drawControl</h4><p>定制CE子元素，button的CE有CE_PushButtonBevel、CE_PushButtonLabel。具体是什么就不再说了文档都有，也通过浅而易懂的命名知道意思了，格式一样：</p><pre class=" language-c++"><code class="language-c++">void MyStyle::drawControl(ControlElement element, const QStyleOption *option, QPainter *painter, const QWidget *widget) const&#123;    StyleControl fcn(nullptr);    switch (element) &#123;    case CE_PushButtonBevel:        fcn = &MyStyle::drawPanelButtonCommandPrimitive;        break;    case CE_PushButtonLabel:        fcn = &MyStyle::drawPushButtonLabelControl;        break;    default:        break;    &#125;    painter->save();    // call function if implemented    if (!(fcn && (this->*fcn)(option, painter, widget))) &#123;        QCommonStyle::drawControl(element, option, painter, widget);    &#125;    painter->restore();&#125;</code></pre><p>​                                                                                                </p><h3 id="开始画画！"><a href="#开始画画！" class="headerlink" title="开始画画！"></a>开始画画！</h3><p>OK主要的虚函数都写好了，剩下画画的，仔细看每个虚函数给的参数，第一个是option包含着控件的属性，第二个画笔，第三个就是它自己，用这些参数足以开始画画了！</p><p>​                                                                                  </p><h4 id="drawFrameFocusRectPrimitive"><a href="#drawFrameFocusRectPrimitive" class="headerlink" title="drawFrameFocusRectPrimitive"></a>drawFrameFocusRectPrimitive</h4><p>这个在adwaita源码中很明显的，它把聚焦矩形缩小一点，然后再用虚线画出这个矩形，效果是这样：</p><p><img src="/qstyle-2/adwaita-button.png" alt="adwaita-button"></p><p>代码：</p><pre class=" language-c++"><code class="language-c++">bool MyStyle::drawFrameFocusRectPrimitive(const QStyleOption *option, QPainter *painter, const QWidget *widget) const&#123;    const State &state(option->state);    QRectF rect(QRectF(option->rect).adjusted(0, 0, -1, -1));    const QPalette &palette(option->palette);    if (rect.width() < 10)        return true;    QColor outlineColor(Helper::mix(palette.color(QPalette::Window), palette.color(QPalette::WindowText), 0.35));    QPen pen(outlineColor, 1);    pen.setStyle(Qt::CustomDashLine);    pen.setDashPattern(QVector<qreal>() << 2 << 1);    painter->setRenderHint(QPainter::Antialiasing, false);    painter->setPen(pen);    painter->drawRoundedRect(rect, 2, 2);    return true;&#125;</code></pre><p>也是显而易懂的，得到矩形后缩小，设置颜色，设置画笔，画矩形。<br>这个不太喜欢，直接去掉算了。</p><p>其中这个helper是用作渲染的类，主要作用是调色和封装一些画矩形的函数，其实这里可以随便上一种颜色即可，这个类就不详细说明了。</p><p>​                                                                     </p><h4 id="drawPanelButtonCommandPrimitive"><a href="#drawPanelButtonCommandPrimitive" class="headerlink" title="drawPanelButtonCommandPrimitive"></a>drawPanelButtonCommandPrimitive</h4><p>这个是相当于初始化按钮绘制的函数了，代码：</p><pre class=" language-c++"><code class="language-c++">bool MyStyle::drawPanelButtonCommandPrimitive(const QStyleOption *option, QPainter *painter, const QWidget *widget) const&#123;    // cast option and check    const QStyleOptionButton *buttonOption(qstyleoption_cast< const QStyleOptionButton * >(option));    if (!buttonOption)        return true;    // rect and palette    const QRect &rect(option->rect);    // button state    const State &state(option->state);    bool enabled(state & State_Enabled);    bool windowActive(state & State_Active);    bool mouseOver((state & State_Active) && enabled && (state & State_MouseOver));    bool hasFocus((enabled && (state & State_HasFocus)) && !(widget && widget->focusProxy()));    bool sunken(state & (State_On | State_Sunken));    bool flat(buttonOption->features & QStyleOptionButton::Flat);    if (flat) &#123;        // define colors and render        const QPalette &palette(option->palette);        QColor color(_helper->toolButtonColor(palette, mouseOver, hasFocus, sunken));        _helper->renderToolButtonFrame(painter, rect, color, sunken);    &#125; else &#123;        // update button color from palette in case button is default        QPalette palette(option->palette);        if (enabled && buttonOption->features & QStyleOptionButton::DefaultButton) &#123;            QColor button(palette.color(QPalette::Button));            QColor base(palette.color(QPalette::Base));            palette.setColor(QPalette::Button, Helper::mix(button, base, 0.7));        &#125;        QColor shadow(palette.color(QPalette::Shadow));        QColor outline(_helper->buttonOutlineColor(palette, mouseOver, hasFocus));        QColor background(_helper->buttonBackgroundColor(palette, mouseOver, hasFocus, sunken));        // render        _helper->renderButtonFrame(painter, rect, background, outline, shadow, hasFocus, sunken, mouseOver, enabled && windowActive);    &#125;    return true;&#125;</code></pre><p>到这里发现绘制的流程基本也一致，显示获取rect要操作的矩形，获取各种状态参数，然后根据这些数据绘制即可，这是通过获取这个按钮的是否透明、点击、鼠标悬浮、使能失能等参数去画，这个_helper也只是封装了这个过程，也不过是判断状态state作出相应绘制而已。</p><p>​                                                                       </p><h4 id="drawPushButtonLabelControl"><a href="#drawPushButtonLabelControl" class="headerlink" title="drawPushButtonLabelControl"></a>drawPushButtonLabelControl</h4><p>这里看了一下，基本也就判断下状态，其中有个判断是否有文字并且点击时字体矩形会稍微网右下角倾斜的效果，这个就实现了比较动态的感觉。</p><pre class=" language-c++"><code class="language-c++">if (hasText && textRect.isValid()) &#123;        if (enabled && !sunken && !mouseOver && !flat) &#123;            drawItemText(painter, textRect.adjusted(0, 1, 0, 1), textFlags, palette, false, buttonOption->text, QPalette::Light);        &#125;        drawItemText(painter, textRect, textFlags, palette, enabled, buttonOption->text, textRole);&#125;</code></pre><p>​                                                                 </p><h3 id="看看成果！"><a href="#看看成果！" class="headerlink" title="看看成果！"></a>看看成果！</h3><p>还记得demo吗，记得上面有一句QApplication::setStyle()吗？</p><p>现在把它弄成QApplication::setStyle(“mystyle”);运行看看：</p><iframe height="343" width="785" frameborder="no" border="0" src="demo.gif"></iframe>    <p>​                                                                                                                                           </p>]]></content>
      
      
      
        <tags>
            
            <tag> qt </tag>
            
            <tag> linux </tag>
            
            <tag> qstyle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qstyle 一步一个jio印（1）——工程目录建设 cmakelist规则</title>
      <link href="/qstyle-1/"/>
      <url>/qstyle-1/</url>
      
        <content type="html"><![CDATA[<a class="theme-btn" href="https://blog.csdn.net/weixin_38627652" title="outline blue larger"><i class="far fa-hand-point-right"></i>去我的csdn博客看看呗</a><a class="theme-btn" href="https://nightcivet.site/qstyle-2/" title="outline blue larger"><i class="far fa-hand-point-right"></i>qstyle 一步一个jio印（2）—— 子元素编辑 样式效果初现</a><a class="theme-btn" href="https://nightcivet.site/qstyle-3/" title="outline blue larger"><i class="far fa-hand-point-right"></i>qstyle 一步一个jio印（3）—— 添加动画 水波纹效果</a><a class="theme-btn" href="https://nightcivet.site/qstyle-4/" title="outline blue larger"><i class="far fa-hand-point-right"></i>qstyle 一步一个jio印（4）—— 整理框架 阅读理解</a><hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>迷迷糊糊的去看了关于qstyle的插件，看完后竟一脑浆糊，都不知道是什么东西。<br>这个qstyle插件主要改了各种部件的样式，从最底部改，比较全面高级。<br>有空就慢慢自己一步步构建一下简单的demo，仔细看看具体qstyle插件的具体实现流程吧。</p><p>框架基于<a href="https://github.com/FedoraQt/adwaita-qt">adwaita</a>项目，后续会在上面添加点效果和样式。代码一堆，要理解还真不容易。</p><p>当然这是后话，先踏出第一步吧。</p><p>​                                                            </p><h4 id="qtcreator的cmake工程目录结构"><a href="#qtcreator的cmake工程目录结构" class="headerlink" title="qtcreator的cmake工程目录结构"></a>qtcreator的cmake工程目录结构</h4><p>新建一个cmake的工程，里面添加目录，一个style用于开发qtyle的库，另一个demo用于随便整一个简单的app应用并用上开发出来的库测试效果。</p><p>先分别在demo和style下建立CMakeLists.txt文件，先是空的，再在上一层的CMakeLists.txt添加add_subdirectory(demo)和add_subdirectory(style)，就能在qtcreator工程看见目录结构了！</p><p>​                                                   </p><h4 id="建立demo目录内容"><a href="#建立demo目录内容" class="headerlink" title="建立demo目录内容"></a>建立demo目录内容</h4><p>在demo那里右键添加一个简单的ui类，选择widget：</p><p><img src="/qstyle-1/new-ui-file.png"></p><p>会生成头文件和ui文件和cpp文件。</p><p>再把demo目录的CMakeLists.txt添加刚刚新建的内容：</p><pre class=" language-cmake"><code class="language-cmake">include_directories($&#123;CMAKE_CURRENT_BINARY_DIR&#125;)set(demo_SRCS    main.cpp    demo.cpp)set(demo_UI    demo.ui)add_executable(demo $&#123;demo_SRCS&#125;)target_link_libraries(demo Qt5::Core Qt5::Widgets)</code></pre><p>先随便拖一个button进去ui文件里吧。</p><p>main.cpp文件整一个app即可，应用style先留空：</p><pre class=" language-c++"><code class="language-c++">#include <QApplication>#include "demo.h"int main(int argc, char *argv[])&#123;    QApplication app(argc, argv);    QApplication::setStyle("");    demo fact;    fact.show();    return app.exec();&#125;</code></pre><p>​                                                 </p><h4 id="建立style目录内容"><a href="#建立style目录内容" class="headerlink" title="建立style目录内容"></a>建立style目录内容</h4><p>这里先把必要的内容写下，目录下新建一个贯穿全文的类——QStylePlugin类，当然我们是他的子类styleplugin，头文件写入：</p><pre class=" language-c++"><code class="language-c++">#ifndef STYLEPLUGIN_H#define STYLEPLUGIN_H#include <QStylePlugin>class StylePlugin : public QStylePlugin    &#123;        Q_OBJECT        Q_PLUGIN_METADATA(IID "org.qt-project.Qt.QStyleFactoryInterface" FILE "mystyle.json" )        public:        //* constructor        explicit StylePlugin(QObject *parent = 0):            QStylePlugin(parent)        &#123;&#125;        //* destructor        ~StylePlugin();        //* returns list of valid keys        QStringList keys() const;        //* create style        QStyle* create( const QString& );    &#125;;#endif // STYLEPLUGIN_H</code></pre><p>网上说这句Q_PLUGIN_METADATA(IID “org.qt-project.Qt.QStyleFactoryInterface” FILE “mystyle.json” )是十分重要的，但我不太理解这是什么东西。查资料说是创建了qt插件的符号，标识了新建的qt插件，emmmm我在暂时理解为起了个名字让以后使用提供名字符号？应该是这样？emmm先不求甚解毕竟有点迷糊。<br>如我的mystyle.json里面的内容是{ “Keys”: [ “mystyle” ] }，意思是我的style插件名字是mystyle这个。app里面setStyle()就可以填入这个名字参数了。</p><p>ok，cpp文件写入：</p><pre class=" language-c++"><code class="language-c++">#include "styleplugin.h"#include "mystyle.h"#include <QApplication>QStyle* StylePlugin::create( const QString &key )&#123;        if( key.toLower() == QStringLiteral( "mystyle" ) )        &#123;            return new MyStyle();        &#125;        return nullptr;&#125;StylePlugin::~StylePlugin()&#123;&#125;QStringList StylePlugin::keys() const&#123; return QStringList() << QStringLiteral( "mystyle" ); &#125;</code></pre><p>这里都是按照格式写一写(chao yi chao)，这个MyStyle类就是我们自己改qt部件样式的具体内容类了！</p><p>然后是mystyle.h，继承于QCommonStyle：</p><pre class=" language-c++"><code class="language-c++">#ifndef MYSTYLE_H#define MYSTYLE_H#include <QCommonStyle>class MyStyle : public QCommonStyle&#123;    Q_OBJECTpublic:    //* constructor    explicit MyStyle();    //* destructor    virtual ~MyStyle(void);&#125;;#endif // MYSTYLE_H</code></pre><p>先留空，再是mystyle.cpp：</p><pre class=" language-c++"><code class="language-c++">#include "mystyle.h"MyStyle::MyStyle()&#123;&#125;MyStyle::~MyStyle()&#123;&#125;</code></pre><p>嘿嘿。。留空留空。</p><p>添加style的cmakelists内容：</p><pre class=" language-c++"><code class="language-c++">set(myStyle_SRCS    styleplugin.cpp    mystyle.cpp)add_definitions(-DQT_PLUGIN)include_directories(    $&#123;QT_INCLUDES&#125;    $&#123;CMAKE_CURRENT_BINARY_DIR&#125;    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)set(LIBRARY_NAME "mystyle-qt$&#123;QT_VERSION_NUMBER&#125;")add_library($&#123;LIBRARY_NAME&#125; MODULE $&#123;myStyle_SRCS&#125;)target_link_libraries($&#123;LIBRARY_NAME&#125; $&#123;QT_QTCORE_LIBRARY&#125; $&#123;QT_QTGUI_LIBRARY&#125; $&#123;QT_QTDBUS_LIBRARY&#125;)set_target_properties($&#123;LIBRARY_NAME&#125; PROPERTIES    LINK_FLAGS "-Wl,--no-undefined"    LIBRARY_OUTPUT_DIRECTORY "$&#123;CMAKE_CURRENT_BINARY_DIR&#125;"    OUTPUT_NAME "mystyle"    PREFIX "")install(TARGETS $&#123;LIBRARY_NAME&#125; DESTINATION "$&#123;QT_PLUGINS_DIR&#125;/styles")</code></pre><p>这边后半部分比较重要，这个目录主要生成的是动态库，使用了一些字段设置了一下这个库，<br>add_library创建接口库，然后为这个库链接一些库，再设置一下他的属性。<br>安装目录在默认的/usr/lib64/qt5/plugin/style里。</p><p>回到项目根目录的CMakeLists.txt，可以添加一下依赖关系了：</p><pre class=" language-cmake"><code class="language-cmake">cmake_minimum_required(VERSION 2.8.11)project(mystyle)set(CMAKE_INCLUDE_CURRENT_DIR ON)set(CMAKE_AUTOMOC ON)set(CMAKE_AUTOUIC ON)add_definitions(-std=c++11)find_package(Qt5Core REQUIRED)find_package(Qt5Gui REQUIRED)find_package(Qt5Widgets REQUIRED)find_package(Qt5DBus REQUIRED)set(QT_QTGUI_LIBRARY Qt5::Gui Qt5::Widgets)set(QT_QTCORE_LIBRARY Qt5::Core)set(QT_QTDBUS_LIBRARY Qt5::DBus)get_target_property(REAL_QMAKE_EXECUTABLE $&#123;Qt5Core_QMAKE_EXECUTABLE&#125;                   IMPORTED_LOCATION)if (NOT QT_PLUGINS_DIR)    execute_process(COMMAND "$&#123;REAL_QMAKE_EXECUTABLE&#125;" -query QT_INSTALL_PLUGINS                    OUTPUT_VARIABLE QT_PLUGINS_DIR                    ERROR_QUIET OUTPUT_STRIP_TRAILING_WHITESPACE)endif()add_subdirectory(demo)add_subdirectory(style)</code></pre><p>其中set(CMAKE_AUTOUIC ON)这一句尤为关键。新建ui类时他会包含一个ui_xxx.h头文件，这个要生成的不是自己写的，但我怎么都没有生成，就是没有开这个开关。嗨呀~</p><p>​                               </p><h4 id="基本完成！"><a href="#基本完成！" class="headerlink" title="基本完成！"></a>基本完成！</h4><p>额其实也没搞太多哈哈哈，就是先搞好层次嘛。</p><p>look at our 层次：</p><pre class=" language-shell"><code class="language-shell">.├── CMakeLists.txt├── CMakeLists.txt.user├── demo│   ├── CMakeLists.txt│   ├── demo.cpp│   ├── demo.h│   ├── demo.ui│   └── main.cpp└── style    ├── CMakeLists.txt    ├── mystyle.cpp    ├── mystyle.h    ├── mystyle.json    ├── styleplugin.cpp    └── styleplugin.h</code></pre><p>稍微编译一下，看到构建目录的demo下有个demo程序，style目录下有个mystyle.so，就大功告成！</p><p>甚至可以运行一下那个程序：</p><p><img src="/qstyle-1/demo.png"></p><p>也可以在qtcreator中项目设置里设置运行程序，点运行即可运行：</p><p><img src="/qstyle-1/run-setting.png"></p><p>​                                                     </p>]]></content>
      
      
      
        <tags>
            
            <tag> qt </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KDE桌面 SDDM 面板 桌面 KWIN美化日志</title>
      <link href="/kde-apperances-opt/"/>
      <url>/kde-apperances-opt/</url>
      
        <content type="html"><![CDATA[<h3 id="闲置了"><a href="#闲置了" class="headerlink" title="闲置了"></a>闲置了</h3><p>这天看着旧电脑，4G的内存已经进入了被嫌弃的范畴，还带着个固态硬盘。<br>寻思算了吧，就装个linux系统折腾一下吧。</p><p>只是没想到，这一折腾就折腾了好几天。</p><p>​                            </p><p>​                                  </p><h3 id="下载安装fedora32-安装kde桌面环境"><a href="#下载安装fedora32-安装kde桌面环境" class="headerlink" title="下载安装fedora32 安装kde桌面环境"></a>下载安装fedora32 安装kde桌面环境</h3><p>直接去<a href="https://getfedora.org/en/workstation/download/">fedora官网</a>下载就行了，下了个稳定版本的32,如果精致点也可以寻找国内镜像源下载速度会快，可看官网速度也不错也就每找了。</p><p>顺便装了官网给的镜像写入工具，操作方法真的是简洁易懂，贯彻方便用户的理念呢～</p><p>常规操作Bios装起来，装完启动OK就行，换源也不需要，感觉速度还可以。</p><p>敲入命令：<br>dnf group -y install “KDE Plasma Workspaces”<br>systemctl set-default graphical.target<br>systemctl enable sddm<br>整组安装，enable sddm登录器时发生了错误，看了下是系统把gtm作为登录器了，把报错的已存在文件删掉，再运行即可；</p><p>OK装完后重启，进入sddm登录界面，在左下角选择会话 Plasma，这一刻，终于看到了心心念念的kde桌面。</p><p>​                                                     </p><p>​                                                             </p><h3 id="开始美化折腾（作死）"><a href="#开始美化折腾（作死）" class="headerlink" title="开始美化折腾（作死）"></a>开始<del>美化</del>折腾（作死）</h3><h4 id="后之后觉"><a href="#后之后觉" class="headerlink" title="后之后觉"></a>后之后觉</h4><p>折腾好久之后才发现，这东西得有顺序啊，不然浪费好多精力时间。</p><p>​                                                  </p><h4 id="改动目录"><a href="#改动目录" class="headerlink" title="改动目录"></a>改动目录</h4><p>其实也就把系统设置里或者软件中心里能修改的都该改，再者把想改的东西找找资料和办法改改。</p><ol><li>全局主题</li><li>窗口装饰</li><li>任务切换窗口</li><li>图标</li><li>SDDM</li><li>欢迎界面</li><li>面板</li><li>桌面</li><li>终端</li></ol><p>​                                                       </p><h4 id="首先应该是全局主题"><a href="#首先应该是全局主题" class="headerlink" title="首先应该是全局主题"></a>首先应该是全局主题</h4><p>打开系统设置第一个就是，最先做的应该是把这个挑个喜欢的给选好，全局主题会改系统的很多东西，在后面再把不喜欢的一个个换掉就是了。</p><p>这里额选了个mac风格的，额别问问就是没钱买原版。</p><p>用了这个主题后缺了很多图标，<del>农村人还以为是mac的特色</del>。没事后面下载一些图标包补全就好。</p><p>第一次设置的话可以把 “使用来自主题的桌面布局” 勾选上，全局主题就更全局了。第二次开始这个选项就得慎重了，它会把设置好的都覆盖调呢。（血的教训）</p><p><img src="/kde-apperances-opt/all_theme.png" alt="全局主题"></p><h4 id="窗口装饰"><a href="#窗口装饰" class="headerlink" title="窗口装饰"></a>窗口装饰</h4><p>我，老窗口装饰家了。</p><p>窗口装饰是kde的窗口管理器kwin搞出来的，我连kwin源码都看过！（牛鼻轰轰）</p><p>咳～ 在系统设置应用程序风格里面可以选窗口样式，这里修改的是窗口上面那条栏的样式。</p><p>更详细点可以直接去专业的设置区域设置，在任意窗口顶栏 右键–&gt;更多动作–&gt;配置窗口管理器 便能看见：</p><p>右侧标题栏按钮还可以选择标题栏上的按钮，我就喜欢少一点，就右边三个就够了。</p><p><img src="/kde-apperances-opt/window-manager.png" alt="window-manager"></p><p>当然还有进阶设置（I’m professional）</p><p>下载的窗口装饰主题包在这里：～/.local/share/aurorae/themes/，在编辑主题包里的rc配置文件，可以微调窗口样式呢。</p><pre class=" language-shell"><code class="language-shell">[jal@localhost WhiteSur]$ cat WhiteSurrc     ...[Layout]BorderLeft=1BorderRight=1BorderBottom=12TitleEdgeTop=4TitleEdgeBottom=4TitleEdgeLeft=16TitleEdgeRight=16TitleBorderLeft=50TitleBorderRight=50TitleHeight=16ButtonWidth=16ButtonHeight=16ButtonSpacing=10ButtonMarginTop=2ButtonMarginLeft=0ButtonMarginRight=0ExplicitButtonSpacer=0PaddingTop=35PaddingBottom=94PaddingRight=75PaddingLeft=75TitleEdgeTopMaximized=4TitleEdgeBottomMaximized=4TitleEdgeLeftMaximized=4TitleEdgeRightMaximized=4</code></pre><p>这里稍微得英语好一点。<br>喜欢标题栏宽一点： 把TitleHeight=16 改成 TitleHeight=25；<br>标题栏宽了按钮居中也得把它挪下一点： 把 ButtonMarginTop=2 改成 ButtonMarginTop=4;<br>其他看着办吧～调这个是真的费劲。</p><p>改之前：</p><p><img src="/kde-apperances-opt/window_manager2.png" alt="window_manager2"></p><p>改之后：</p><p><img src="/kde-apperances-opt/window-manager1.png" alt="window-manager1"></p><p>就还是很大变化的不是吗！</p><p>一般来说这些效果重启才生效，<del>可我是什么人</del>不过这样对调试比较不友好，可以使用qdbusviewer重载一下kwin，再重新打开窗口即可看到效果。</p><p>method是这个：</p><p><img src="/kde-apperances-opt/qbud-reload.png" alt="qbud-reload"></p><h4 id="任务切换器"><a href="#任务切换器" class="headerlink" title="任务切换器"></a>任务切换器</h4><p>在 窗口装饰 选项下面有个任务切换器选项，主要场景常用于按下Alt+Tab就行窗口任务切换时弹出的窗口样式调整。</p><p>下一个搭配主要风格的在可视化那里出现，选中即可：</p><p><img src="/kde-apperances-opt/window-selete.png" alt="window-selete"></p><h4 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h4><p>图标在系统设置里，选一个就好：</p><p><img src="/kde-apperances-opt/icon-setting.png" alt="icon-setting"></p><h4 id="SDDM"><a href="#SDDM" class="headerlink" title="SDDM"></a>SDDM</h4><p>系统工作区–&gt;开机和关机中找到登录程序，再选一个设置就行：</p><p>sddm和窗口配置一样能通过配置修改主题样式，<del>麻烦得要死</del>不过看别人上传的很好了就懒得改了</p><p><img src="/kde-apperances-opt/sddm.png" alt="sddm"></p><h4 id="欢迎界面"><a href="#欢迎界面" class="headerlink" title="欢迎界面"></a>欢迎界面</h4><p>在下方的欢迎界面选择，在登录后一段载入系统桌面时间会播放这段欢迎界面，简洁就好：</p><p><img src="/kde-apperances-opt/welcome-select.png" alt="welcome-select"></p><h4 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h4><p>面板就是在桌面边缘那条栏目，右键编辑面板进入编辑面板模式，把喜欢的加，多余的扔掉即可。</p><p>这里设置了屏幕边缘，让它两边空出来显得立体一点？额个人喜好问题。</p><p>高度也调高了一点。</p><p>也忘了去掉了什么东西，反正觉得多余的右键去掉即可。</p><p>有一段时间发现显示已打开程序的功能没了，找了很久才知道那个部件叫任务管理器，缺了的话加回来就行了。</p><p><img src="/kde-apperances-opt/panel-setting.png" alt="panel-setting"></p><p>左下角程序启动器，在全局主题中可能会安装多一些插件，这个就是装了Mac风格的。<br>先右键配置换一个图标，因为图标是一个苹果也不太好哈哈哈哈。</p><p>右键显示替代方案，选一个喜欢的风格：</p><p><img src="/kde-apperances-opt/menu.png" alt="menu"></p><h4 id="桌面"><a href="#桌面" class="headerlink" title="桌面"></a>桌面</h4><p>在桌面右键配置桌面就可以配置桌面了。</p><p>首先选择一个插件，有挺多在桌面播放音视频的，算了花里胡哨。</p><p>就选了个可以为图片加点效果的，壁纸找个淡颜色的，搞起。</p><p>下面图标选项配置下放置在桌面的图标的样式规则，简洁大方即可。</p><p><img src="/kde-apperances-opt/desktop-setting.png" alt="desktop-setting"></p><h4 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h4><p>终端必须占有一项！</p><p>其实也没什么，把菜单栏去掉，加入标签页，背景随机浅色，换一下字体，额也就完了：</p><p><img src="/kde-apperances-opt/terminal.png" alt="terminal"></p><h4 id="桌面一览"><a href="#桌面一览" class="headerlink" title="桌面一览"></a>桌面一览</h4><p><img src="/kde-apperances-opt/full-screen.png" alt="full-screen"></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>桌面右键菜单太多太杂了，也没找到资料说可以怎么改，看来也只能找找文件管理器的源码改改看O不OK了。</p><p>折腾了几天。。</p><p>有什么用？</p><p>没什么，就是臭美。</p><p>​                                                        </p><a class="theme-btn" href="https://blog.csdn.net/weixin_38627652" title="outline blue larger"><i class="far fa-hand-point-right"></i>去我的csdn博客看看呗</a>]]></content>
      
      
      
        <tags>
            
            <tag> KDE </tag>
            
            <tag> Linux </tag>
            
            <tag> 桌面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>留余庆，庆余年</title>
      <link href="/liu-yu-qing-reaction/"/>
      <url>/liu-yu-qing-reaction/</url>
      
        <content type="html"><![CDATA[<h3 id="书名为庆余年"><a href="#书名为庆余年" class="headerlink" title="书名为庆余年"></a>书名为庆余年</h3><p>由于不小心看了百度百科，其实一开始对故事的主线还是比较了解的，所以时不时看到猫腻布下的坑也直接明白是怎么一回事。</p><p>​                                                                  </p><h3 id="主要故事与人物"><a href="#主要故事与人物" class="headerlink" title="主要故事与人物"></a>主要故事与人物</h3><p>其实也就是有人忘恩负义甚至恩将仇报的故事，但偏偏那个人是没有人之上的帝皇。而施恩者的周围人不甘心，不公平，转而复仇。<br>围绕了三个人物三条线，范闲，叶轻眉，皇帝。<br>猫腻说范闲是常人，有私心有恐惧有怕死，所以他并不喜欢他。其实也不是，小范大人不是一直在改变身边的人嘛，常人二字只是相比与其他人。<br>其他人都是理想主义，也像是偏执狂。萍萍偏执复仇，皇帝偏执江山，轻眉偏执天下。<br>可以说萍萍小范这条线的人似乎很有道理，也似乎没有道理。比起大江山和大人口，一条命可能没那么重要？<br>同理皇帝似乎很无情但似乎很合乎常理，这是个封建时代的皇帝，没有仇一说，皇帝眼里只有江山和权力，似乎是没错？<br>大义和个人之间，从来都没有对错。</p><p>​                                                 </p><h3 id="精妙的布局以及伏笔"><a href="#精妙的布局以及伏笔" class="headerlink" title="精妙的布局以及伏笔"></a>精妙的布局以及伏笔</h3><p>回顾此书，在京都上北齐下江南应该也只算是打怪升级的过程，殿前欢朝天子迎来结局。殿前欢并不欢愉，朝天子去亡天子，感概猫腻的布局。<br>人人都爱叶轻眉，因为人人向往自由。叶轻眉当着一个最理想的理想主义。<br>但我爱陈萍萍，这个没有太多神奇的实力靠自己一步一步的谋划把皇帝逼到绝境的地步。谍中谍局中局，甚至参合着对范闲的保护，可谓智者谋者之极致。<br>所以几乎看的时候只是快速略过武功穿越神庙枪支武器这些不太符合常理的文字，好在这在此书里本来就不多。我只想看局，此书本来就是在写局。<br>我知道，我早知道，我知道他知道。在这么多知道下人物的动作和反映，成为最喜欢这本书的主要原因。</p><p>​                                                          </p><h3 id="参照现实"><a href="#参照现实" class="headerlink" title="参照现实"></a>参照现实</h3><p>比起现实，书中更是对凡人更温柔一些，他们有与皇帝反坑的机会。也故意把皇帝写强大一些，因为本来就是如此。矛盾很足，没有对错，权谋尽致。仇该不该报，皇帝究竟对还是错，这些都深深印在脑海里。<br>就像朝天子卷中，皇帝无数无数次问自己问若若自己是不是好皇帝自己错没错，当然他只是需要别人肯定一下他，他偏执而自信。庆也能在封建中繁荣。<br>只不过仍然逃脱不了反派的事实。在多数地方都把他塑造得黑一点。<br>回顾历代帝皇，朱杀尽开国功臣，赵杯酒释兵权，在自由与民主面前，封建皇室当然很肮脏和令人愤怒。可这的确是过往存在的历史。</p><p>转念一想，若没有穿越的狙击枪，也不可能打倒自信而强大的皇帝吧。或许整个故事也只是南柯一梦呢。</p><p>​                                                     </p><h3 id="一些触动的笔记"><a href="#一些触动的笔记" class="headerlink" title="一些触动的笔记"></a>一些触动的笔记</h3><ol><li><strong>“至老方知事不协，三分在人七在天，莫愁伞下无知己，好生耍着只等闲。”</strong><br>范门四子之一科举失败却收到范来信。感概三分在人七分在天，只等闲尽是安慰，也意在等一等范闲回来。</li><li><strong>“留余庆，留余庆，忽遇恩人；幸娘亲，幸娘亲，积得阴功。劝人生，济困扶穷。休似俺那爱银钱，忘骨肉的狠舅奸兄！正是乘除加减，上有苍穹。”</strong><br>听别人说这是全本书的主旨，赶紧百度了下是什么意思。来自红楼梦，大概讲的就是要报恩。读完后回首，主旨，的确是主旨。</li><li><strong>“钓鱼台，十年不上野鸥猜。白云来往青山在，对酒开怀。欠伊周济世才，犯刘阮贪杯戒，还李杜吟诗债。酸斋笑我，我笑酸斋。晚归来，西湖山上野猿哀。二十年多少风流怪，花落花开。望云霄拜将台。袖星斗安邦策，破烟月迷魂寨。酸斋笑我，我笑酸斋。”是为殿前欢。</strong><br>当初看完殿前欢这一卷，满满的不能释怀。以长公主为首的一派大人物包括两皇子死去，阴谋逐步露出水面，的确唏嘘不已。当初第一次看到感觉悲从中来，虽然不明白写的具体意思是什么，对皇室的人来人往，死来死去，晨起朝落，血流成河同时新旧替换感到无力。曲子来自《殿前欢 次酸斋韵》，表达作者怀才不遇的心情，虽说和书有点不符，但心情还是符合的。</li></ol><p>​                                    </p><div class="note info no-icon"><p>特别是对酒开怀，花落花开，酸斋笑我，我笑酸斋。是为殿前欢，是为无奈。</p></div><p>​                                                    </p><a class="theme-btn" href="https://www.douban.com/people/148010245/" title="outline blue larger"><i class="far fa-hand-point-right"></i>去我的豆瓣看看呗</a>]]></content>
      
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>辉哥金句</title>
      <link href="/king-of-hui-s-words/"/>
      <url>/king-of-hui-s-words/</url>
      
        <content type="html"><![CDATA[<h2 id="辉哥的金句，永远的金句-（持续更新）"><a href="#辉哥的金句，永远的金句-（持续更新）" class="headerlink" title="辉哥的金句，永远的金句 （持续更新）"></a>辉哥的金句，永远的金句 （持续更新）</h2><p>​                                                  </p><details class="note "><summary><p>blue fas fa-bullhorn modern</p></summary>  <p><strong>1.如果你要问一种犯罪那么多，那一定是犯罪成本太低了。</strong></p><p><strong>2.滴人舒舒服服，使嘿努力。</strong></p><p><strong>3.富贵人家都是科技，穷人靠变异。</strong></p><p><strong>4.一件事从不同的方面看系不同评论的，一个人以不同的社会角色去看也是不一样的。</strong></p><p><strong>5.不觉得有什么事情是绝对正确的了。</strong></p><p><strong>6.你分心越多，对那件事的欲望就越不够强烈。</strong></p><p><strong>7.听个歌有嘿深度。</strong></p><p><strong>8.想死那阵点只鸡就好嗨快乐。</strong></p><p><strong>9.傻嘿只可以玩傻嘿游戏。</strong></p><p><strong>10.有些情绪是要用粗口才能表达出来。</strong></p>  </details>   ]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
